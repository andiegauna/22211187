<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>


<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Question 2" />




<meta name="author" content="Andrea Gauna" />

<meta name="date" content="2022-06-17" />

<meta name="description" content="Question 2">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","bibliography":"Tex/ref.bib","date":"2022-06-17","csl":"Template/harvard-stellenbosch-university.csl","output":{"pagedown::html_paged":{"self_contained":true,"toc":true,"css":["Template/default-fonts-Texevier.css","Template/default-page-Texevier.css","Template/default-Texevier.css"],"csl":"Template/harvard-stellenbosch-university.csl","template":["Template/paged-Texevier.html"]}},"author":"Andrea Gauna","title":"Question 2"}
</script>

<title>Question 2</title>


<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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IC5HI0cjYSBgsCBgZrACYiCwAFBYsEBgWWawAWMjICA8ijgtsD4sIyAuRrACJUawEENYUBtSWVggPFkusS4BFCstsD8sIyAuRrACJUawEENYUhtQWVggPFkusS4BFCstsEAsIyAuRrACJUawEENYUBtSWVggPFkjIC5GsAIlRrAQQ1hSG1BZWCA8WS6xLgEUKy2wQSywOCsjIC5GsAIlRrAQQ1hQG1JZWCA8WS6xLgEUKy2wQiywOSuKICA8sAQjQoo4IyAuRrACJUawEENYUBtSWVggPFkusS4BFCuwBEMusC4rLbBDLLAAFrAEJbAEJiAuRyNHI2GwCUMrIyA8IC4jOLEuARQrLbBELLEIBCVCsAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsS4BFCstsEUssQA4Ky6xLgEUKy2wRiyxADkrISMgIDywBCNCIzixLgEUK7AEQy6wListsEcssAAVIEewACNCsgABARUUEy6wNCotsEgssAAVIEewACNCsgABARUUEy6wNCotsEkssQABFBOwNSotsEossDcqLbBLLLAAFkUjIC4gRoojYTixLgEUKy2wTCywCCNCsEsrLbBNLLIAAEQrLbBOLLIAAUQrLbBPLLIBAEQrLbBQLLIBAUQrLbBRLLIAAEUrLbBSLLIAAUUrLbBTLLIBAEUrLbBULLIBAUUrLbBVLLMAAABBKy2wViyzAAEAQSstsFcsswEAAEErLbBYLLMBAQBBKy2wWSyzAAABQSstsFosswABAUErLbBbLLMBAAFBKy2wXCyzAQEBQSstsF0ssgAAQystsF4ssgABQystsF8ssgEAQystsGAssgEBQystsGEssgAARistsGIssgABRistsGMssgEARistsGQssgEBRistsGUsswAAAEIrLbBmLLMAAQBCKy2wZyyzAQAAQistsGgsswEBAEIrLbBpLLMAAAFCKy2waiyzAAEBQistsGssswEAAUIrLbBsLLMBAQFCKy2wbSyxADorLrEuARQrLbBuLLEAOiuw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) format('truetype');
}
body {font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;}blockquote {font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;}code {font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;}pre, code {font-size: .95em;}</style>
<style type="text/css">@page {size: 6in 9in; }@page :blank {}.shorttitle1 {string-set: h1-text content(text);}.shorttitle2 {string-set: h2-text content(text);}.running-h1-title {position: running(runningH1Title);width: var(--running-title-width);text-overflow: ellipsis;overflow: hidden;}.running-h1-title:before {content: string(h1-text);}@page chapter:left {@top-left {content: counter(page);}@top-right {content: element(runningH1Title);white-space: nowrap !important;}}.running-h2-title {position: running(runningH2Title);width: var(--running-title-width);text-overflow: ellipsis;overflow: hidden;}.running-h2-title:before {content: string(h2-text);}@page chapter:right {@top-right {content: counter(page);}@top-left {content: element(runningH2Title);white-space: nowrap !important;}}@page chapter:first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: counter(page);}}@page :first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: none !important;}background-image: var(--front-cover);background-position: center;background-size: contain;background-repeat: no-repeat;}.front-cover {break-after: recto;}.front-page {counter-reset: page 1;}@page frontmatter:left {@top-left {content: counter(page, lower-roman);}@top-right {content: element(runningH1Title);white-space: nowrap !important;}}@page frontmatter:left {@top-right {content: counter(page, lower-roman);}@top-left {content: element(runningH1Title);white-space: nowrap !important;}}@page frontmatter:first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: counter(page, lower-roman);}}.back-cover {break-before: verso;}.pagedjs_page:nth-last-of-type(1) {background-image: var(--back-cover);background-position: center;background-size: contain;background-repeat: no-repeat;}.level1 {break-before: avoid;page: chapter;}.front-matter-container .level1 {page: frontmatter;}.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {break-before: avoid;break-after: avoid;}.footenotes {break-before: always;break-after: always;}.figure {break-inside: avoid;}.main .level1:first-child h1 {counter-reset: page 1;}caption {break-inside: avoid;break-after: avoid;}</style>
<style type="text/css">:root {--background: whitesmoke;--pagedjs-width: 6in;--pagedjs-height: 9in;--color-paper: white;--color-mbox: rgba(0, 0, 0, 0.2);--running-title-width: 2.5in;--screen-pages-spacing: 5mm;}html {line-height: 1.3;}.abstract {border-width: 0.5px 0;border-style: solid;margin-top: 0px;margin-bottom: 2px;font-size: 12px;}a[href^="http"]:not([class="uri"])::after {content: " (" attr(href) ")";font-size: 90%;hyphens: none;word-break: break-all;}.references a[href^=http]:not([class=uri])::after {content: none;}.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: " (page " target-counter(attr(href), page) ")";}.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: " (page " target-counter(attr(href), page, lower-roman) ")";}.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: unset;}h1 {font-weight: bold;font-size: 23px;}h2 {font-weight: bold;font-size: 20px;}p {font-size: 12px;}.sourceCode {font-size: 10px;}.toc ul, .lot ul, .lof ul {list-style: none;padding-left: 0;overflow-x: hidden;}.toc li li {padding-left: 1em;}.toc a, .lot a, .lof a {text-decoration: none;background: white;padding-right: .33em;font-size: 11px;}.toc a::after, .lot a::after, .lof a::after {content: target-counter(attr(href), page);float: right;background: white;}.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {content: target-counter(attr(href), page, lower-roman);}.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {float: left;width: 0;white-space: nowrap;content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";}.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {content: var(--chapter-name-before, "Chapter ");}.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {content: var(--chapter-name-after, "");}.subtitle span {font-size: .9em;}img {max-width: 100%;}pre {padding: 1em;white-space: pre-wrap;}pre[class] {background: #f9f9f9;}abbr {text-decoration: none;}@media screen {div.sourceCode {overflow: visible !important;}a.sourceLine::before {text-decoration: unset !important;}}pre.numberSource a.sourceLine {left: 0 !important;text-indent: -5em}pre.numberSource {margin-left: 0 !important;}table {margin: auto;border-top: 1px solid #666;border-bottom: 1px solid #666;}table thead th {border-bottom: 1px solid #ddd;}thead, tfoot, tr:nth-child(even) {background: #eee;}.kable_wrapper > tbody > tr > td {vertical-align: top;}.footnotes {font-size: 90%;}.footnotes hr::before {content: "Footnotes:";}.footnotes hr {border: none;}.footnote-break {width: 1in;}body {hyphens: auto;}code {hyphens: none;}@media screen {body {background-color: var(--background);margin: var(--screen-pages-spacing) auto 0 auto;}.pagedjs_pages {display: flex;max-width: calc(var(--pagedjs-width) * 2);flex: 0;flex-wrap: wrap;margin: 0 auto;}.pagedjs_page {background-color: var(--color-paper);box-shadow: 0 0 0 1px var(--color-mbox);flex-shrink: 0;flex-grow: 0;margin: auto auto var(--screen-pages-spacing) auto;}}@media screen and (min-width: 12.32in) {.pagedjs_page {margin: auto 0 var(--screen-pages-spacing) 0;}.pagedjs_first_page {margin-left: var(--pagedjs-width);}}@media screen and (max-width:1180px) {body {width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));}}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Question 2</h1>
<h5 class="author">Andrea Gauna</h5>
<h5 class="date">2022-06-17</h5>
</div>
</div>

<div class="front-matter-container">
<div id="TOC" class="level1 toc front-matter">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#do-you-really-like-wet-socks">Do you really like wet socks?</a>
<ul>
<li><a href="#table-1-the-frequency-of-rainy-days-in-london">Table 1: The frequency of rainy days in London</a></li>
</ul></li>
<li><a href="#wet-and-cold-no-thank-you">Wet and cold? No thank you</a>
<ul>
<li><a href="#figure-1-the-average-tempreture-in-london-in-2020">Figure 1: The average tempreture in London in 2020</a></li>
</ul></li>
<li><a href="#theres-a-lot-of-snow-in-london">There’s a lot of snow in London</a></li>
</ul>
</div>
</div>

<div class="main">
<div class="page-break-after"></div>
<div id="introduction" class="section level1 unnumbered">
<h1>Introduction</h1>
<p>There are so many reasons not to move to London but in this document I will name but a few. London is cold, London in rainy and third, there is a zero percent change of running into me.</p>
</div>
<div id="do-you-really-like-wet-socks" class="section level1 unnumbered">
<h1>Do you really like wet socks?</h1>
<p>It rains nearly 50% of the time! The amount of rain in London basically guarantees you’ll be stomping in puddles and going to work with wet socks. Do you really like wet socks? (Note: I kept receiving the error: Error in dir.exists(lib.loc) : invalid filename argument and i couldn’t fix it in time so I just screengrabbed the tables so I could knit my markdown, the code for the table is in “frequencytable.R”).</p>
<div id="table-1-the-frequency-of-rainy-days-in-london" class="section level2 unnumbered">
<h2>Table 1: The frequency of rainy days in London</h2>
<table>
<thead>
<tr>
<th style="text-align:left;">
Weather
</th>
<th style="text-align:right;">
Frequency
</th>
<th style="text-align:right;">
Percentage
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
No Rain
</td>
<td style="text-align:right;">
7963
</td>
<td style="text-align:right;">
100
</td>
</tr>
<tr>
<td style="text-align:left;">
Rainy
</td>
<td style="text-align:right;">
7372
</td>
<td style="text-align:right;">
100
</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="wet-and-cold-no-thank-you" class="section level1 unnumbered">
<h1>Wet and cold? No thank you</h1>
<p>Not only is London super wet. It is also super cold. Where the average annual temperature in London is a chilly 12.7 degrees, in sunny South Africa it is 17.5 degrees. From the graph below it is clear than many days are spent below the average in London.</p>
<div id="figure-1-the-average-tempreture-in-london-in-2020" class="section level2 unnumbered">
<h2>Figure 1: The average tempreture in London in 2020</h2>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABUAAAAPACAMAAADDuCPrAAABm1BMVEUAAAAAADoAAGYAOjoAOmYAOpAAZpAAZrYAv8QzMzM6AAA6AGY6OgA6Ojo6OmY6OpA6ZmY6ZpA6ZrY6kJA6kLY6kNtNTU1NTW5NTY5Nbm5Nbo5NbqtNjshmAABmADpmOgBmOjpmOpBmZgBmZjpmZmZmZpBmkGZmkJBmkLZmkNtmtrZmtttmtv9uTU1ubk1ubm5ubo5ujo5ujqtujshuq8huq+SOTU2Obk2Obm6Ojk2Ojo6Oq6uOq8iOq+SOyOSOyP+QOgCQOjqQZgCQZjqQZmaQkDqQkGaQkLaQtraQttuQtv+Q29uQ2/+rbk2rbm6rjm6rq46ryOSr5P+2ZgC2Zjq2Zma2kDq2kGa2kJC2tma2tpC2tra2ttu229u22/+2///Ijk3Ijm7Iq27Iq47IyI7I5OTI5P/I///bkDrbkGbbtmbbtpDbtrbbttvb27bb29vb2//b/7bb///kq27kq47kyI7kyKvkyMjk5Mjk5P/k///4dm3/tmb/yI7/25D/27b/29v/5Kv/5Mj/5OT//7b//8j//9v//+T////38nvCAAAACXBIWXMAAB2HAAAdhwGP5fFlAAAgAElEQVR4nO29jb/dxpmYhytSZXwryqRqHjqSaSprra2UZNLKlbxttrYcOet1K1VdX0VKorVEJ618RW5khqrdVrn8DHV5/+zg++BjBhi8mAFmMM/z+0m85xzgne/nDIABTnIGAAAikrUzAAAQKggUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAELKAQI+S5IXP3ScTEc+uJQfvj210nCQXZqaTttwV2Z53LiZJcu5/m7DHV++9lO5y8c37+7dO776evvXyb+5P3QpgKdwLNB3t4nFoibuvj+omqLS9F+hHScZ4HmtO301KDm5W7z26Xr51/rNJWwEsh3uBnmS9+8UV5wfpsJswlENI23eBnhRKMz/u2JsxpXRj/sXbCmS2FcCCOBdoppCX6v6+Bka62V7aKwo0TfrgNxMTSl65l3aWTw5rEabvHaSH6qcfJ1VBzLYCWBDnAn14mLx4Z9XOjUClSAV6NDHpbBp5o/gz7S5FmtkfxbfuSXkywGwrgCVxLtB0HF9ZU2EIVM4MgU7a76RxjqeSbyP7ZTizrQCWxLVAi5OAq3ZuBCplKYEeN7YvNZmd77zZfstsK4AlcS3Qoluf7E/xt8Z1PdIevZceix1cri6kphvdPP3oMDl4ObfP3ezT5Nyb96r9TrNlMgev3G8O1U6Iiuwgr3FJuLPVUfZ+/t7L+Um7YknM74pE8tH5qPHO1Kw2027k9Hg/fWru2ivAo3zNzrnLjcQLKi0f5RnMdjv3Zs8daoF+9Xqn/IoI+cKgTu2a7Neu8LLFOzt2ytyn9GDzm0fxLWS2FYBrXAu0GIONmULaz+vLpVWfP/2oupL6SjEas2F2VKmnXqhSL16p3jl4vx7ivRAVLYH2tsoEely+dWX/cR4zz3R5QTm5XEadlFUDgda79gLv3+it0GkKtNqqJw+VQPfXsevy9yOoatdkv06F583c27FVZhVlttModTdpzjMnbQXgGscCrYb68f746qh31NVcnlKM+XTzi/nL9OPGQpVy1O3feeEvGrJrh6hoSqy/VSrQv6nfunHUSifb+ieVDcrsT8vquEDrXVVZ29NZodMQ6MV6m+7xq0KgzfwVmysi1ALc167Rft0KzzLd37FZZhVZPXRPePbVaLYVgHMcC7QSZzqqqinHSeu8/81io3x5yuNsTnOl3C1Jvnf/7PG9YqHKjfvl4pUr5W75hOZOPlTrHdoh9uyP7fpb5ZbKji/vZkejeUL1ipjCaefTA+ivruvTGc7qPm21QOtde4EzD2VvnD3+uFekhkCL3OeTRvUkrclRufm+PP0IeamzhO9eT5pbje3XSeeKJsFmmVVUJ3tOlGd6pm0F4By3Aq1nBdWU4azplPJoPpumlEOwGhjHSXPzxqeZjTO1FMtZHlU3OSlC7KkTVGx1VCeUHavvXVdPjC8UE8/ydtSpWR0XqHLXLHDDfz0VNgV6pd6/Y4++QOvFP3V5FBH2tZuX/4rpfk2qsip2bJRZRR1Nfap80lYA7nEr0P05qvZlpCvVHxfO2qNgPydtTFiro7R03JRXY6vtT8rhqAixp5aYYqv9ffoNETTOLFR5LgU3NaujAq127QdO3zmvu7WmIdAqg/2ll32BHrXy1yl/FaERqPKf0X6dhKp5anfHY/3Zz7OiyutDfa0azbYCWAC3At0PrsYUK1tan3X/anraNN5JLUTFObJixto811VZTxGitVsxZhVb6TJYXQCpIxWjc2JWxwWqODFcBs6vXl36W+WRbkOg2llq/53WScK+LovtuxtdMdyvRVlW1Y7q6mrksPTygBrNtgJYAqcCbV5D2F83qO4PL0XausM56U9KC07/+O9+dVhdmNjPYfZDvBuilYv6olB3q/2ga4RtCLQe/3mOpmZ1XKDlrorA9Vsv/7onnIZAuzH3aA/8c8rZci9Ca6PiWMFovxZH9YmV3o5Dq1Oz86nVvFZ/dtNsK4BFcCrQk7YWGoe65dytmqd0NdseZsUzzHIKge5PcqoF2p7j6ATaFoFSoK3x3xfoWFbFAu18sZzv3FjuVqD72j1ZVKDZGYP6rIX2+rrZVgDL4FKgXS00jpaLhTtarzWH2X5t5ZoCVc5Ax7I6S6DZQvr6De1V+O0I9E6r4arzPGXt1HHMtgJYCJcCbaxdOsuHzv66Q/p+dfilmjk0hll5GuDipZ/8/X+6NnAIr598NAWqXXBjfAg/JauTBKoswON/83q+VqutBgsCPe6ewjA8hNft10IlUMUVw252m/dAqO63MN4KYClcCrR9wWC/pqWY2dTXTRTnrtprePK1lWeqi0jVdZ7B01/Ni0i6BTc6gfYvIk3JqkagRz2BDhbgtLcQVCZQzcWgdgTzi0jjAtVcRFIKtLt+V32Xu9lWAIvhUKCdFYL7xSfZny/+p2uNS6l1zz/uLUtqDNX+CsnGMqZuiFY+6mVM3a3GBFptX06mp2a1LdDGdLMr0F5ghcj6JZom0GYijeVInQidja6Y7tek+lSxo0ag+XePLvt11ZltBbAcDgXafULjSXPZY3YHZTkEG1PT6qC/fXDb2C6z0n6p97NqIb0ixJ5aYoqtxgRarQN/d7+Gf0pW23dB7b8wegLtB27IpzUVbuZ1okDVC+I7EdobDSykNxCoeiG9QnMnzR/p2Gf2Rv3h++ZbASyIQ4F2pwSZ7so38vul6/6eDdTsjsn8DkjFwW1+XJzf47i/DSY7Eda52bAdYs/eP/2tRgW6vxPxpiSr+7SzyfL5/726MtTdtR84v9qc/1LaV411O+28ThSo4s5KRYTWRvvaHd2vnc6+wnu3cvYF2liD287sK81nzZttBbAk7gTa7+/t21faC1Ba1667c7M99aPJ91xRh9hTfnZTtdWYQC+2k5mcVWXaPznsC1QZuFPIZtUaCbRJ+fS31mtlhMYvt/2o/NRov3ZDXzlT76gUaCerRfkb+yoqRLsVwJK4E+hxr0tXZyzLP/d2Pa3X65QPbmsOs3rcHPz375Y71cuFLv/L2mzdEJ10y8sa3a1Gr8KXz2w7+KfCrO7TflY9Je7mQ4VAFQX4svZx58SfWKB1HpqPpetFqAx6cLM+nWy0355GrXZ3VAm0u4ir7Dad39s02wpgUZwJtL5U0n7rxfZV6oqv8ucQv1wtGG8Ns+JBw9kPf+/HeP674+nmjVsgOyGa3MlWt39PtdX4MqbsPEHjUc6Ts7pPu3gKdHpEqxSoogCPP8knwP2fPBcLNHtidPbYqeaDkRURvno9S/az5vU4o/3O+p92d1QJtHPDWt0zil98v7hf2GCwFcCiuP9ZY5c4vfuEW1sAYJgABdqY3zhdPI1AAWCYAAXaOLl67HLxNAIFgGECFGi+ICj7obWvsusu7h7Ag0ABYJgABZqvgepcG3EBAgWAYUIU6H7FT/cnOO0mg0ABYJAQBVr/YvpPnC79Q6AAMEyYAgUA8AAECgAgBIECAAhBoAAAQhAoAIAQBAoAIASBAgAIQaAAAEJEAv3zz3a7q3/9TfHi+Ye3dru3vrCZKQCAEJAI9Otdzqt/yF58+07+4vt/sJwxAADfEQj0ya2rPz87e/qz3Q+yV7d3r31x9vSD3Wvf2M4aAIDfCAR6e/d29s+TW9mss/h/Og+9+lvLOQMA8Bz5RaRv38nU+XUxD03/fdtWlgAAwkAu0Ce3sqP227tf5K8elCIFAIgGsUD/dCtT5/MPykP3QqcZ3ylhgRQAbByh5m7vdlf/7gyBAkDMyDT3/P/457d2V//XlkA7C5kSBAoAG0euuT9nx/CKGWgVGIECwMaZobkHu9e+QaAAEC8zNJc7U3sVHoECwNaZrrnnH5TOzAVarf/srQNFoACwdUR3Iv1g/6/2TiQECgBbR3Qv/O6n35w9//0uc2Y6H31VeS88AgWArSPR3IPiaUxX8yP5p5qnMSFQANg6Is09/atUn9UjQJ9+mPrzrd6zmBAoAGwdZ5pDoACwdRAoAIAQBAoAIASBAgAIQaAAAEIQKACAEAQKACAEgQIACEGgAABCECgAgBAECgAgBIECAAhBoAAAQhAoAIAQBAoAIASBAgAIQaAA80gSOnu0IFCAWSQJBo0XBAowhyTBoBGDQAFmkCQYNGYQKMAMEGjcIFAAOQkCjRsECiAmQaCRg0ABpODP6EGgAFLwZ/QgUAAp+DN6ECiAFAQaPQgUQAz+jB0ECiAHf0YOAgWYAf6MGwQKACAEgQIACEGgAABCECgAgBAECgAgBIECAAhBoAAAQhAoAIAQBAoAIASBAgAIQaAAAEIQKACAEAQKACAEgQIACEGgAABCECgAgBAECqCFxyXDMAgUQAc/2AEjIFAADfxkHIyBQAHUDP1oMV6FHAQKoGZAoMxMoQCBAqjRC5RjeyhBoABqtAIdOraHuECgABrGJqD0cUCgADoGz4AiUECgAAPoL8EjUMhAoABTwZ9QgkABJoM/oQCBAkwHf0IOAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABpsFdSFCDQAEmwX3wsAeBAkyBJzFBAwQKMAGeBQpNECjABBAoNEGgABNAoNAEgQJMAIFCEwQKIbG+ufAnNECgEBA+uMuHPIAvIFAIBz9mf+vnALwBgUIwcP4RfAOBQjAgUPANBArBgEDBNxAoBINfAvUlH7AmCBTCwTd/+pETWBEECgHhj7V8cjmsBwKFkPDFWX6dTYDVQKAA00GgkINAAaaDQCEHgQJMB4FCDgKFwPDDWvgTMhAohIUv3vIlH7AqCBSCwp+Znx+5gHVBoBASnHsEr0CgEBIIFLwCgUJIIFDwCgQKIYFAwSsQKAQF/gSfQKAQFvgTPAKBQmD46E8f8wRLgEAB5sKsOFoQKMBMOC8bLwgUYB6sDIgYBAowDwQaMQgUYB4INGIQKASDp45CoBGDQCEUvJUU/owXBAqB4LGmvM0YuAaBQhh4faDsabbAOQgUwsBrgUKsIFAIAwQKHoJAIQwQKHgIAoVAwJ/gHwgUQgF/gncgUAgG/Am+gUABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFGACLKWCJggUwBwW80MLBApgDLeTQhsECmAKDzSBDggUwBQECh0QKIApCBQ6IFAAUxAodECgAMbgT2iDQAHMwZ/QAoECTAB/QhMECgAgBIECAAhBoAAAQhAoAIAQBAoAIASBAgAIQaAAAEIQKACAEAQKACAEgQIACEGgAABCECgAgBAECgAgBIECAAhBoBAbPJEOrIFAITJ4JjLYA4FCXPCrHGARBApRwe/CgU0QKERF4AINNuNbBYFCVIQt0HBzvlUQKERF0AINOOtbBYFCXAQsoaDlv1EQKERGuApCoP6BQCE2gjUQAvUPBAoQCAjUPxAoQCDgT/9AoABhgD89BIECBAH+9BEEChACnAD1EgQKEAII1EsQKEAIIFAvQaAAIYBAvQSBAgQB/vQRBAoQBvjTQxAoQCDgT/9AoAAAQhAoAIAQBAoAIASBAgwx7cQjpykjA4ECDDDt0jcXymMDgQLombb4kqWa0YFAAbRMu/2Hm4XiA4ECaEGgMAwCBdCCQGEYBAqgBYHCMAgUQA8XkWAQBAqgJlchy5hgCAQKoKSUIQvpYQAECqCCw3EwAIECKFBeEEKo0AGBAihQCZQpKXRBoAAKFALloB56IFAABX2BssoT+iBQABXaCei0RU1O8gbegEABlKjPgE6QItPVCECgAGoUl+CXui0J84YCAgUwQ+ZPyUBg7hoMCBTgzGzOJziAF4mQi1XhgEABTN049QqSTIRc7g8IBArgYs6XiA2KQAMCgUKEzLw+ZJyGKCwCDQgECvHR1ZMbZSHQCECgEB09P9lWVhlp7jG8ncyASxAoxEbfa5YFWoUSh8WfwYBAYQ4hDnSF1xz4s2lQUYjxt2B9ECjMIMipkmpi6MCfe4Pai2ojEtgEgYKcME/WKY+s7Z4ArcPbqqAwazoCECiIsXzqcDHc5rpTK1aSCrWmtw8CBTFJqONanWdL5WhXip0KCrWitw8CBTENgQbW2jp/WjVo8++ZgUOt5+2DQEFMU6DBN7fFcvQO4BHoZkGgIGdBg7pOwWo59mFshcWfnoJAYQaLCdR5Eo7KYS0s/vQTUZP8+a92u6tvfVG8eP7hrd2uetEITGPHwEICdZ+GvXK0Y1jLOf70Ekmb/H6Xc/W32Ytv38lffP8P3cC0dhQsItAFEnE2VWTquGkELftgd/XnZ2dPPyikeXv32hfZi9e+6QSmz8SBSjy2lWFsN0nCSRthFrvR5uUJQmF60z7/YPeL7N906pn+++RWrtFv3ynmo43AdJpI6KvH+qTLVG+ShN34k+4fCYPtfHpP8ea375SH67d3b5+dfb37Qf7i6+xFKzA9KBa6zrCvEEMtSRK2608EGhv6dr77epK88PmzH755X7NBLtDbxXQ0Pa7/QScwPSgWOtJw4ZBJ/pySsFV7CvMAAaNr59OPsk6QCvRacv5z5Rb5UfvzD8pD9ye3qpOg3ymhB8XCAgI1OjhHoLA4unY+SpLzPz584fPTXybJi8o5aH7wjkBhEYGaXIrxQaCseI8MTUOfJMmNs2fXXkgnn3cOk5uKLR7ky5gaAu0sZKILRcMiAp2ej4n72Mov/owKTUsfJVfOSoGeHScX+hs8uHU1O/mpmIFWgelD0dAR0GqTMEnCtv3JsqW4UDf16bsH79cCfXj4Qu8s6NflMnoECme9WddqkzBJwmvNl2ETqLtNoc5SoOU/TX6/q5Z9chUeznqzrtV8JEkYf4IciUCf3969Wp3wrNZ/sg4UAKJDdwifXTgqzXnSvQx/u3HfJnciAUC0aDSXXzgqBJrKtH0R6evmfe/PP9i9yr3wABAlGs09PExeuZ8L9NH1JLugtKd8/FJGdtrzKU9jAu/x5SSn1Xxw8tYDdNV/nLbMxcODSy+l/15pffJg1xLo2dMP07/e+qYbgIYFb/DFNNaXS3lSrojR1v6Xh1X7XNFtMhyYdgUZ1qXgi2kcLNj3olwxo6/8x59cTNvm3OXPhIFpVhBhXQq+mMZqPpIEg/oAv4kEfmFfCr6IZkY++jshUD/Q3copnXjuA9OqIMCBFXwRjTwfir0QqB/oFtIrHyAyKTCtCgIQqH5HdbDVyxU1Q3cizQtMq0aKYkRPGOQurLC6aMq0Z/pTa1B7GYWpDD1MZF5gmjVOtIebU3a3rIWVVVOnLcuEpkrwpw9o70R6ceZJUNo1ThSjetpA721twxGryiZpo91mfH/l+1bzChPRVP/jj5Pk3KU3Sv5S97NIQ4Fp2BhRDPapc0rl7vaztRgG+hwu5JqZhxG0F5GaSE6I0tpR0h/so/JQxugFtJ2t5TCYgI5kTvXx/jVmXRMECjbpicJg+jUpnqVsLUhHoIocjOZO7c/inbWKBTkspAcxipHbdYHB9Gs0CQTaq+n99uuVCzIQKEhRjtxBf1q7Ai3Mq6cXkSYXsletGHQtECgI0Yzc1ptThrnyY2uC6AWZFnN864EtEOh20V2F/2OTe5LAtOi20Q7d5lsThrnmc2t+UPjTPOr41oNbjNXA1EIiUG/gIhLIMBq65sNcu4EbPUzTjqn+Depi+mcDqSHQ1UGgIMNs6E71p8ag87NrnJwivfH8G28x9LFJxjvpcRFpbdQVf/oPn5b8zfXk4G//noX00MVw7lNuMrblwjOpEV/rbpqUC9R22fbx8OeqjNf8w8MXBf5EoJvH0HjlJiNbJk0sZnI0Od0nZlubbmG/ZPto+HNNDKr+WPSjHjTq5rHphJZA3XcdbVKqDwwyNrLFkt8NsCgGLSqbgtJXto9NI0wyaHMTWSbGJqCKm0kH0zGbgNpdOAUeYNBGsoeD0vowiQkGbW4indhp9uvnwDBTg1sIBMqENQyMZqAIFNxjLNDmNtNnds0oQ5nQvzMl3rQY/T1Mt4eVGG+h06OEQ3hYBCPRNDcSTO0MszAtT5OjGm7PKPIdzTKmX1WPAn3jR4eyX4an6WEyHgi0d+xsJ4mJERBoKJgspGcZEyyEiTYcC7R3LG4nhWkREGgojAv03JsSfyLQOFlgpmYqUElWlPsYm8ye8BBoKDhrIJo+Ruwc6xolMnYRSZIVzT4T/GnboHaigTMQKNhjoWHfTGTYn9OyMi/7dguPP8NAdxGp8TtyD3/0Xa7CgwGzDzxNd21uV//d2lmSlZF9RoLZPurGn0GgOwfaWPrJQnowY65DZst3+urNfgTdPmPRbAsUgsBAoCykBzNmOsTmztYFOhoOgUZJr7U7jwLNYSE9mDDPIbP27u5sW6Dj8RBolPRb+6Qv0JuSwPSj8Jmqg55CpgSwKlDbF5EMMoc/Y6Tf3Kf/Orv96OBSfS/ST34nCkxHCh6pgmQB7ArU5jImw8zhzwgxOAcqDExPCh3pJK67v2GApqMmm0ghOInNtPsY2X0Zf2JpnzBYxiQMTCMHzqwZYWv/iQYVzeXm5XX9+BMzsnYuoISF9KBhpkAb/hwP0PamKF39LnaE44m4vBE55Aw0xGn1s/B3/wnLmCJknkCb/hwN0DSnOOEhf9oy6PwoFjKBQT1C1w6P3mv0f9aBxshyAu1sZlcS2xIOAvUMTTt0nmeHQGNk1lAV+FO1hnO2KjZgnGbmN1CcbaFph+MkObiULWb60WFycEMUmBYOnjkj1dyfQwKd74rwjdPKffjF2Riaq/DvZncfpf+/mbmUByrHypyBaj7Se1Lo+HNWVwreOLq6AS/QrQM9eP+s+kX4I+5EAgHGA73vuI4/5/Sl0AWq+XZZNU+wZ3Ah/Ulyof7/5MDJPwIA2BbTBJodvT+7JnuYyNolBQCwjJFAT9/ND+GLB9nxPNAwCPnITp33pIl2D/02g8FdYynV0E9BbB1NsxzlZz+LU6E8DzQItjfKkjaKz3pbrZJPJdby41/RoIGmXR4eJpc/yy7DX8lkyvNAvceBQkaizfvYMH2dHRtvORLozGgWMyQKhHIXQlfLR/n9RydJcnCY5LPRyYFpvwVx4JCRaPM+Nk5frcfmW24EOjOc1RwJ/ckIXAJtJX+ZHbifHmXtwDpQ33HgkJFw8z6ekoFVBDo3ngOlS5JfJfG4GKjj/5h68/TOxYtvip5sR+sthwOHjMSb9/HEHAwLVDH7nl0Ns/O/sEA7Ca2s76hwVsU03nLELdDe+d/Z9TC/NpdVWDclBLocuqvwlz+bG5jGWwz7/vRAoIM3dLbjq/xp5QTm/GN4cSbmpIVAl0O3kF50+2YrMI23GPb96YNA9xMrRSh9ArPTbvpzroXFu09OqZkaAl2OwTuRZgWm8ZbDwYAZiTjv4wl5aP/RT6GXhFWBCkNUYWbsPi2hTm7x52IM3ok0KzCttyAOxstIyHkfz0crudn6s+PP5VBlN6DsB46mko+TF2eeBKX5FsXBeBkJOe/j2ZgIVJYB9/5Ux5amqMwv/lwITS0//jhJztU/DS/5iU7aD1yi15w1g87O42B8s3fN4zHgVkF7EakJ98KDbwxI0ligui2W8Gc3/hwLrunP2M2NQCFMBoxjKFD9Jkv4s53CvEnzuv6MeqizkB6sYXUszfSfbpbX32p2TqfhQqCrEWSmrYJAwRZWx5LhDHJoZ/VRcnebpTvqlgQaZq6tMljy03szAsdbp5FidSzNDKb3Z++GJQQqJ8xcW0Vf8ruvZyc/n/1Q9iwRBLogXvTg8cE0IZuzR6ben9X7qw1+dbJBmgiBagV6+lFWLalAryXnRTclRVynS+NHFx4dTFOy6WBk6gW6jkHN3vUbBDr0QOXzPz584fPTX/I8UM/xpA+PDaZJ2VxAoCsb1PRdv/Gk762IpugnSXKjvCP+ziG/C+8zvswCRvIxLZtLCDS4ezZ9JPrq05Q9/1G58pEix8LfhZ+TLTDGGwuYTUA1C9+nBRvc1Tx/3lRdwMRee+rCFw8TKQXKr3J6jT8WGMyFPptT3pVspN/an6qDUNHdidT4QXh+F95rPLLAUCa02RzyqkF6Uw1qlCcAQxBo8AQigRF/CvI/33+BVB34i+4QPrtwVJrzhN+F95tAJDB0qO5IoKNhvaw6D7MEOjQtlV84KgSaypSLSH4TyIhTZtOlQA3ielh1XkodNGga6uFh8sr9XKCPrieip9PTBcAEhwIN8wA9zFxHi66djtMmvHh4cOml9N8rosD0gAXYwGCbIQwzf4ZVPWHmOl60zfTlYdWQIn8i0CXYxGCbUQKDA/jQaifMXMeLvpkef3IxbcVz0h+IpwO4J9nGaJuRf8Wu9VthVo5RrkMr1IZx1g60sHOSJmtnxhf2tRFm3ZjkOrxSbZfhZvjjjMA0sGsQaJ9mdfhZNWM5MvWnb+WKFH0rZM8DTZIDDuG9BYH2aNeHjzUznidTf/pWsjjRNcLpu3UzvSJ6ojLN6xy/BOpNJhr14UWeWpg018jnHrU56ASa+fPg0t9++m9+dJiI1tEj0AXwzZ/rZ8OjClFiI3++lzEutHciJd8rJp6nHyc8D9RX/BlKnmTEd7mEI1B/69AvtPfC71d/HnErp7f4YgtvxOVJNnRYqael/OltLfqE7mlMjds3eR4ojOGNQD0f+XbqaSl/+luP/jD0ODvVC/PAVH5E+CNQz4897VTTUv70uSY9QXcI35qB8jg7GIYRZ0oQtURzGjP0ODvF3xMCU/fe4XBEyAZcjEN0pMxeVAkCNUa/jKla/nmcSI7gEah/OB0SUn/ST1r4USUI1BjNIfyvsvWfl9789N9l/778Rs5fTjqQp+59w/GYkPqTjtLAlyoZzYcPmfQC3UWkpM+0iSj16xnezSq8y9D6+FMlBv5cP5M+gEBjwZ/BWbJMhjwq8DgetdFgPrzJ5frwOLtY8GhwFiySIa9KPIpXbaTPiFfZXBkEGgve9folMuRZkcfwqY0GcuJTNsJqt3gAACAASURBVNcGgUaDd51+OX96VOhh/MnuUNUFV60O0VfBP3xa8/cspN8C3vX6hQ7gvSrzCN7kFoGaoauC/W/KJVMvH5WBqVzv8K7bu85MgCPdl8wOVl1wteoOTR2cJE0Q6EaIreMHKFBfGK46KrVC+zi7g9/8seaeJDDV6x0inwQ9Urz2Z52x/h8eMFx1PuV0VbTrQCUPUW4Fpn69QyJQjwVkgsfZr7PW/8ML/MqNrxg8zk4YmKr3DoFAvZ7CmeBt5uua7f/R2mbdHK6XeiDoDuER6AaZLlBOIroiGaC9zZq5hDG0j7PjEH6DiCeg7lozVkUYCJTvrgDQtE7rNz1kgWl3D5k6Ip0LNFpFjAuU2X8I6Brn0bXk/BsV0x5kVwam2Z0iHFimu5XbuR7E8SoifIH6m7Ml0VXBR80GZR2odzgeWXX4ZfwZY2epS97/o72Bp7Xjb84WRXsOFIH6jOOR1QivTsdS2n4rwjH9Km5XRXMEzk9pXgR1zEgbrsXAQnrBcXszcPRV6xDH4mmF1/nTRtpRC3R0Ib0tg7qo4bhbroFuHejca0gI1CVLCnTgc+cJRY4dgTqpYlquhIX0ISLpvhO2HglvcfAwCgexUdOzYizRB8KGhfQhIui+UzZfTqBcihhkbYHq90OgJdqLSFfmBo69Zp0i9OdUgw5/au06koUwG8VCRTdba2KoodTxZ4GmAk7fPbgxM3D0VesUoT+nGdRSMJAzv54brWW109ADcjSH8L/6UZIcXGIhvb9M672TnTe4Kf5cDnk9V3t2/GntQQj0gAzdRaSkCetAQ8fypBF/+s++jTr+tHUtETIQaBTYHguMKt9ptnfxLwJ1gbO6oda9gqEQFwr5TfchnWYcBBoJDIWosCJQOs04g7VzKvkxpCow9e4XDIWYUNlSMKGk04yhr567r2cnP5/98E3ZPfFUPMBqKKebTCjto6vO04+Kq0fPriXnRTcl0VDucDcMGGALsa9oR1WunYA6SCtmdPV5lCTnf3z4wuenv0ySFyVzUFrKGe4GAkNsIfYV7azK1f50kFDcaGr0JElulI8UuXMo+n0k2soV7q6NctV1IfYV7bDK25GdJERn0Qn0KLsXvnwm03FyQRI49pp1heBi6uqRoUWiwF06nSTdxI8W3dOYsueBlgJ9eMhCeo8IWqAMuIyFBNoM7SIhvm7P9HciZc4sBSp7OGjk9eqOkAXKgMtZRqCt2A4SWuD7NgAQaGiI+q3R5s5HRDt8vEMvboFuq911h/DZhaPSnCeiy/BbqiS/EPpzgkHleTMK7/jycwDs68Fhlauq28UR/MSYG2t3TUnyC0eFQFOZchHJK4T+NDaoPGdm2Wg92cJVYn6zxPdIR3DShLR7yQS6tXbXFOThYfLK/Vygj64noh+Y204V+YfQn4YGlefLPB/JhDxtkn3J3dVBp4bl/hwxqCRPm2l3XTmO0yJePDy49FL6r+jXPTZTQ+Fju9NKIyVK7OQpUNxWgIUKHmwlQfzNtbu2HF8eViWV/TrSZmoofCx3WnkoBNrBdQ1Y8+eAQa0GDA99OR5/cjEt5rnLnwkDb6WGwsdup50Tq9wTgRb4XwXWm2lz7e7wioGryDAVF/6UG7Q9E7WRp0BxVgn2QkqzqN9ja+2uWcb0q8bvyD380XdZxhQ2FvusjVGPP3Nc1cL6rT20y8bafWghveqFeeDt1NEGWH9Oog5iJ0+B4kigVoPO8OeQQS3kzBMMBMq98LDHzqhHn2euBGo56gx/RtHAvTJ2fpAzhzuRoMbO4IhkeA3jdAK63qK1uAWaPQq0C88DhT3RjA33uKjK9fW1fg4WpF/G03/9xhs/Ojy49EbFT34nChxD7cVJJENjCRxU5fr6Wj8HC2JwDlQYOIbaA/CO9e0Vk0ENljEJA0dQeSETR/eOkvXdpTDo2llyBQvp42T9QQbOWL9pewbdbH9DoFESzyEWrEFXoNvtbwg0RmI6SQUr0OlgG+5vCDRGNtyhwQcQ6PzA26ur7bDhDh09I626UKOrj+A32OcQaIxstDPD6NWaxVpdcQlpk53OoUD/MwDAtkCgAABCpgj09N4cgcr39QTXRxyLHNEoE9jgoVTcJD1GNls4f9s9Daovyt3Xk+SFz5/98E3ZPUnhV5Lr5l6kOykT2Fonjp6+P70TqAfJO0FXlNOPsnKmAr2WnBfdFh9+JXkvUINdlSlsrxfHDgJdDV1RjpLk/I8PX/j89Jeyx4EiUOfxDfZVJrHFbhw5hv5c/btzgx1PU5aTJLlRPpPpzmGkzwP1XKAmOyPQOGg06UjLrtzw2+t3msIcZb8GXz7U7ji5IAkcfjW59owVf46umkagEdBoUYMusVSu/EvePprH2b178H4t0Hh/E8m1ZubER6DQgAZdiaEHKpcCjfhXOV13yhnxhzVYva/cCH9uENeHSq5ihw4CDZRBge4/GDDoItmE8KG7DKA7hM8uHJXmPOFXOdv40Z1G/Tli0EUyCeET8gGL+3xrwucXjgqBpjKN9CKSBl+606g/62sKvuQYAiTkDrRAvjXRHx4mr9zPBfroepJdUJoeOMD6NmJSd3LafkMnQAcEqs1TmIME3BKwQJfIuC74cZruxcODSy+l/14RBQ6vvo2Y1J/W6XhJM4+9/I5MXJfMKARAuAJdJOfa2F8eVqmL/GlXoB4135RWWannNQSa9PKrzVOowwTs0z1gCbNnrCvQs8efXEyTPnf5M2Fgi7n2qf0mtMpqXU9p0JE8hTtOwDbtfhBsv1hZoHMD24vsVQsKBbps/pNu0p0D+EGB+lLTsBLdXhBqn0CgVSSPxvWUzDS2XTr/rWyqphPDAvWhpmEl+r0gzB6xTG/WBH/8xyaiwJsU6KS8JD2c56+f9PQPPKlqWImNdIKFiqG7E6kzns5NfqzyJgU6MSseGNT4g9VyCh7QbPFt9IGlSmEo0GTyYlAEWm+/Sgm06Zn5c/26huVoNfk2+sC6Aj39h49TZf7lp59++qvD5ODNT//m9ezp9NMC27+ItH6DTm6VYtNVuqQ2OcUHPX16UNdgBZO27LS5zS6wWldaV6DZFLRa/nknV+ejaxPXg9pfxuTBqBa2iu9aUvjT05zCREwas9fodv25Tl9aWaBHDV0WD1Se+kgR6wvpF28KVXrCfPhtJfy5WYyas9/qdv25rkFdJ6N8t3igcsnDw0ydUx+r7Eagq59EFObCZyu1xelzTmEiZuPG2eha9/t4mZR1F5Eatmw9HNQ8cOAC1SUozMQ6vcgo1c7Mc2Qf9BoQI+Om/MD26KojdXrW0iySqk6grRlohAJd98vTEmYFmNTLg6+TqBhu2PoT+/4sYrUEutFOoz0HeqHztx/nQGcHNY2xhXY3LMF0f4ZcKVEx2LKNj+z7szO1XbDTLNw9NWmdJMkrhS9PP0qyp9PfOVzxKry9gWscZQMCNS7CdH8GXCtxYeDPWnV2U1zLoEt3T11SR2kuXn7jjTeyJzJdyBfWT1xJb7kQNv1pEmcDqjAvQkxfK5Ghby1HbdkOu7hAF++fupSyiWfJ9+5nAj24OTGw5TLY9OcUg85Ncz0mlNa0oAg0OLSNpW7L2d2lE3ZIoJb6UTPM8h1Un1D5PNA376V/n/7q1+vdC2+PSdUbvCgcdCYEuh2UbWnUuIMbmQvUUkdqhfFJoHMDezjGplVv8J5w0Jfw53bQ+tNw3b3Rx2P+nN2VdMnNDGuevrPAHg6y5at3XRyUNabq2zpaf44uBDYwaG9rjT9ndqZOGK8Eelo9DvTuP5n2HJEisI+jzBN/LpYFBwnZCOlBE8BZvx3sCLQdVre1G4H6cxHp0XuN746JD2IqAns5RLzx5+qZWJHYy+8tJlLTTimHdxClZRy9EWbpzqVJqv1A0Bc3I1AfJj/OvyQ9KOMQi08SYsG+jYY2MU5LvakrgXqykP44SQ4u/egw+y85uCEKzABRY6nnjCXgKPh8nJc/VizqaHQDC83nVxh5+sp3T9/NbtxM/38zc+m0ezirwB6ODy9GrWuBTIu+fJUgUDdYqNXxEPb86WYZ0/KoUy4fJnKc3755lExcQ18E9m98+DFsHQtkWvgVqgSBOsFCtRoEsNp4foWRpq58t3z00kn5GJELyo1GArs8QhXv6MG49Umga1QJAnXC9C9OXQB7qcTAiECzo/dn1yTH8G6PUMU7etD2brMxpZjrVIknzbAxBF+cmv2NDDonq5tCdw40P4SXPQm0DOx2giXfc/3Gd5oL/wXqyamUjSFpd+XuRvchzcvrltBURfGbSMWp0Kk/5lEGdlLJM4a8PwKdcdbGYM/JE5Hlq8SLRtgas743m/4ciUDjtdDUxcPD5PJn2WX4K5lM/TmE34ZAxRjl37yQW6gSqJjzvTlBoNBCV1tH+f1HJ0lycJhMfJRyGdg3gQ5/RQfRcQzLbl4WhsyWmPG9ubo/g+2F2lx/mR24n2bPVfZpHeisZh7xp/ct6KCPB1FusMuwQFfM0ipJz2Qg0/8x9ebpnYsX35T40/VFJFF91zt19w5jJuaik/tfarCOohv54E9Lq+ot5GdKis4CO1+mI0+hu/fKX7+mBJJN8B5FL1qzY1nr2CsUQncV/vJncwO7X6cz51J2a+9AzOQom96XG6yjaPORbuCmlxRRbXXsNUaxbiG96PbNVmCHxZhX4f29AxGomw4SQsFhbdz0kqSLpWiWsmeUqPJd2dr5dmAEqk191s5O/IlBt4GrlnTTS3r+3IxAyzuRBvj2nR+Ufz3/8NZu99YXvcABCXRBi8xMx5k/MegWcNWSbnqJZX/6JNDsGXbDJ0Fv70qBfvvOLuP7f+gGDkmgix3HemcrBLohnDXlQgK1Fs9K9gwTVb/9+OMkOXfpjZK/7C5ken57Vwn09u61L86efrB77ZtOYJelkFTUfnvV3sv60+USBb9yBMsx1JbzWljYS0Z2sOxPzy4iNemeEP3zz3aVQJ/cyuee375z9bedwE6LIfNn26Au8mWUCWeJC/s4At0GA205s4lllhvbwbpA/VnGNCzQr3e7n/6pFOjX9b9vdwLPKcd4Ncj8me+zojDc6koUG39uBn3v0jey4t2hAFM6Sm+H3t62/RnKQvqvX/27swelOG/vfpH/W73eB559xCDfXxcxj7qmL5wKVBgcf24FbQcYM+vYW2cSg/Z20KYVdA+U5rsU5vMPykP3J7eqk6DfKZl/wCAOoA+5dnvNSn1kR2nZAu690GJYkwNmnRNjLDNDVx4aC+kNo3rHYMZP72k/cihQF5LrC3RVgzrZde2iwepoml/XMxTvj7pWKtCt9k59ce6+np38fPZD9bNE+gLtLGSSV9SmBSr/th3Nt+uiba/zbw91Gy0pUJ0xVx94jtAV5/SjrKypQK8l51U3JelnoFVgrwTqzTG8GIOMu/dncLUGOeZS1Hczc392lDkWOGx0xTlKkvM/Pnzh89Nfqp8HGppAq5YNth1N5O/en8FVG+QMO9FIoEa9q7Vza4dgB94ImuKcJMmN8o74O4eqB4u4vArvpqbLiKE2Y0ugQwZ1nbyb+OAWdcsp2nSgmc392TCoSeCQ0ZQn/1G58pEix6rfhX/QWf9pdR2o05oOtBnbAl08/wh0kyiadE4rD/aSbXYfdYGKh4mUAlX+KucDp3ciOa3pfnCj5NZu/XUNikC3RtGWihYdauSRDjDcSxbtPUslpk6kUGcpUOWz7SqBPv9g9+ry98LbxUgM69sDgYI9RI05tpM/vWSxXMwV6NnTFZ7GZBejNh/eaJnGWlOgWz2FFSui5hzfyZdeslw+dIfw2YWj0pwnqsvw+4tGTz9M/fnWN90N1q9EQ4ycNH5sstABw3pf8X6MDLCCqB+Z7ORHL1lwmGhSyC8cFQJNZaq4iDQeePVaNGS+QM0ba36TrjwBXTpZcIMzga5+qaDOxLoCfXiYvHI/F+ij68nY0+nVgdevRjNmC9S8tWy06Zr+XDpVcIU7gXrB+gJNp6BJcvHw4NJL6b9XRIG9r+WS5QRqp1FXnH+G0qQwxsoCdd2XPBDo2ZeHVR5E/gxHoLMvIpm2Vjhf4F3CzTloEDWoTX8uY1CXaZQpaT95/MnFNAfnpD8Q7z7z1ipowvRR/wkChZAQtadNfy5hUJcpVAk5C+w69xaryCiQfiPDDhGuhsLNOWgRNadNf7o3qMv4dTrOAjvOvk9D2iwn3Y7jS+7HQaBbZul2tdSbPOmOuoX00iP3fWC3pfNrTJvlo+9PP3I/jk91DXZZvGXtDF1fOqROoElyoH6SsnHgmARqSN+foWQ/pLzCFJbvh1aGrjfDR3Mn0kf5NfiXfzMj8KYFKky4708PuoARRU7DyS+YsUY/tOjPVpBVeqc2xewXPdJpqPhQfjGBrjGibR2BBCak4DIMY6zSD90Mn3V650CCp3eyVfTJuRuiQ/mlLiKt8q3j6CvUc8LLMYxhox9O33t2L1Jke6XeOZze40/yQ/nvChS60DKmVerMUqcLTEcBZhnGsNCoa/SJfrbX6p2jyT16L/ttOUHgRRbSByvQAKdzCHSLWPLnWgbtveGZQE8/yQ7jEaiDhINzEQLdJJb8uY5BPcjHwGend69nGZKdBJUXxLQSAhdoQJe0i5wi0G0yr0VXHYX9TBRvLpgdfTozL8OLS2DeGquN58hEUhU2smKDCT58rar8uVR+NMlkZz5TzssXgkoLMKU5DLZ1U5Nr9xg7GJZhX8vbKDbYxAOBqv25UIb0dyLNvBVJmP9p7TG6raua3IJIDOum2SJbKDbYxVt/rvkwkVSgl383M/ASAh1rvdUb12NM68aDKQb4zNqdw0eBnv79rPvg88BLzkA1W9uoyq2aw7huECgMs1rfKBL2UaAtTj/5b5dbxuSbQDerDgQKgVP2Ss8F+tXry64DnVR45wINzx2WvnsUW87PG4A96n6ZdPryoh12OJXT4lbORRfSTym8a4GGN/syzu2EooVVAxAHjQ7c7cpLdtihZLLJZ4ZoKaj7hfTVtgPb25qArnqOZ+oeEw3qJB8AciZ8rRebdrvygh1Wm045+RQ/E3SpGfSwBGbab12BTk95Un6ZWIKXmHXMlSc3dTbUb98tJ5+Sg/cysK1yjVTR0MezK3iZRtLEFyQ9Lb+rdz6APoZd2GOBPi6eR39w6dADgc6oIwvVu5Q/FSlIOognnQpAjHEf9qOr95MvniCSLaR/dm19gXZqaUqFySu4k+AS/mwuwGi/j0AhJsz7sBc9vZt+fhNncv4394u/1xZopzanVJlcJmJlS2hkU1XWicnjTwicCf3eh56uEOj5X9+v//ZLoJP0IBboshJKVLQ/mB7OTVYB3COf+KyCagb6cmlQ3wQ6rWqlDdHfz0VjKiaaOoMKAwMESVD+7An09KM88/lDlBFo441pQcwSaSfXFSizSYiSoPq9Ip/lVaSXf7e2QHVTsonH8OJUZ4VpxRvKml6gzCYhSkLq98qMVovo110HqpmRmdeuTHwzEzXJhOp7oS1SWVoAsCy6oVo+kj555Z408FwJKHwyVS8yFfVngTOk1thZG7PxeceroiQBYCkGxmh5KC98MP3c0a+ckC0zPVNKW5ZsY++OMRUxe/7EoAB+MzhEq0P5F1f4WWOlQM2mZbPN03f2eEj1FkmPoZiKTWaVAyA4il4fTN8fy2V+KL/G78KrBWq+57zUFRkRJdoXqJkehUUHCBzxsF8Jg0zeve6bQI3cI0tSG3B8195WCntWm4zFDKsTAVhCMVZshrYasIhqP2QZ2OJFJOUno7vJEtR8YJpX5ZuKTmHqTwQKEaEeLBZDWwxYhrUesQpsbxmT5v2RvZa8g1OVaLsjjGSr/ZmjLgTgOe4E6mo8eSzQM3WRzVQ0uapmNZpi524/MMt0b1dBZgBCxZlAnY0onwWqCxyYQFtvjOzevTdJkBeAYEGg+8ArCdTWHZy6bUwT7ccz8We1ggN/QpQ48icCbQYeqQpZPRnU8Li2p8Xrb5p0bumcWAaA0HHU/RFoM7KB6OaGVcQYTrf3iXmDJTqmFwIgcIqOb737uxpTAQrU2YKEjj+1qzoF8Qw2xJ8A7nBlDesRq8BuDNf+w1F85ddVV2zjmTDOJv4EcI2bMRWQQJfTilJinTet5mYfGn8CBEQ4Al1QLAYC1c1RRWk1lryqBYpQAbwkGIEuOTXTW6zrz/7CJVFSmlRmRQYA5yBQ87Qabym2EGVPO9Md2QgAfACBDiWmeFuXG1H+lDvp/IlBAXwDgQ6kNiU39gQq2ggAViAYgS58IDuWUi83CBSiJ8JOGo5APbuU0s0NAoXYibGXBiRQu99vs4N1A4gsZ7QT/gTPybtnlP00JIHaxEFTi0Ia7RRhv4SQSNqsnZ0liVSgTpq6FdA0utF2sfVKCIoEgToI7HM1um/r+HoSxErXn1F1+40KdKQZnbd1jF0JIsWSQMMcL9sU6Fg7uhZonF/GECf2/BngeNmkQEdbMiiBBtmvIB4s+jO8nr5FgRq05UJH8DYSCLNfQUTUnX2+P4Pr6ZEK1LGWLHaHQPsVxMT8LopAe4H9FqjjA2Pr/gyuY0FMzOigxa7B9vNtC3TtPNiKE2DHAjChcfAfZD/fokC9MailMEF2LIgNUSete3eo3XyTAvXCoHbYTEFg44h6aaN7B9rLtynQDXlnK+WAbSPrp81x6qiXOx48CNR3NlIM2DTCAed+nLoePnEI1LgOJZXd3MdFY+FP8J6FBTppQDsdQBsVaLvijOtQfhQi3x8gfOaYcN6Yc5KtCVlxFnhlj/T8afjUOPWG+t2b+zj/ugPwE7Gp9DuZjTlH2TJmswLd179xJeo3HG7l6lP3rQXgKeKuPzyyhpKaMCVCoDOYL9CB/V0LFB1DGFju+RPGnEEUBDqD2QIdCuBYoG4bH8AeTvw5MuZGx4drfyJQgw3XE6jz5gfwErMxZzA+XA+gCAQ6+yLSYEM1P2p9MVrMuEd1CbAERmPO2KCucnkWh0DnLmMabqfmJw1/8iQRADFGY86H8eGtQK1Wi3Gw4Sno+A6tdp2R4Xa6CBRio93zu2OgeO3D+PBVoKvVy4BBDbe216w+dBCAVVAc2ak3QaDKvVeqGE3Cw/PPRPmmxSno7EAAodH154BBF85ZKwvOAs+JvNpXy7SE1VvbzPzq/QNgbQYG1PrjIwKBTgnjm0BZSA/RMzSgVh8f2xfopDg2BOrDgQXAZljteNSEzQt0WiArAvXgwALAb5zNahbGT4GutxLIztaeNjaAJ4iOC53mSIinAl1vLfq0hP1tWAB/cTooF8VXga53N+S0hL1tWABvmTAqi438HWbeCtQSXp8/AYgS81Hp/djdukCdnj/xvG0B/MRYoP7PfjYvUIffYb63LYCfmAo0gOPH7Qt0bJ4obh7v2xbAUyZOQD0eZBEIdBhx+wTQuACeMuUMqNdjLHaByhsogMYF8BWjgWNvjDkbp5ELdEYLIVAAx9j0p6MLIS6C5oGD8AoCBfAYm/50MlLjFmgyx4L4E8A1Nv3pYqxGLdBklkBZxgQQAgjUDTP9yUJ6gBBAoG6Y608ACAAEOpaULDH8CRADXEQaTmnWOUwECrBx3A3z8AU6+yoQ/gTwEvXglAxZZ8M8eIFyHR1gm6iHp1+DNm6Bch0dwFfUq2Q8O2yMXKAA4CdJojKob+N9QwItKtWfqgUAOUl3aHfeXTVzNcELtFvPHtUtAIhRD2rfBnn4AvXOoG7SX7tUAMuCQJfCL4O6SX/tUgEsjXpIrz/CW2xBoEVyngjUTQZWLxbA4qiHtF8jwTeBSuvGF4G6ycH65QJYHvWI9moceCZQsSUQKMAm8bvj+yXQGZrww58IFMAyXvd7rwQ6yxNe+BOBAsTEdgRaflGtbRk3psOfAD6yIYF6gpsCBF8tAFsEgVrHTf5DrxWALeKVQDlSBYCQ8Eug85YxSRIEABDjmUClImTiCgDL45tApYlhUABYnE0IdBsXnwBAi6fDG4ECgPf4Or4RKAD4jrcDHIECgOf4O8I3IVB/v58AYD4I1DF+Vi4A2ACBusbHugUAKyBQAAApvvoTgQKA/3jqTwQKAAHgpz8RKACAFAQKACAEgQIACNmWQD09TwIA22RTAvX1Sh0AbJMtCdTbtWIAYECAo3dDAvX3bgUAGCfE0YtAAcAHghy+CBQAPCDM8YtAAcADFhu/VpPYkEDDPAQAgIylBGo3jS0JNMiT0ACQ4U6gzZi2E9mUQENcBgEAOS79WUVNbGt6WwIFgGBx6c8iboJAAWCjuPRnFjlBoAAA5iBQAAAhOoHaCm8pTj8wAgWAtdEI1Fp4W4F6gREoAKyO8iKSvejWInUDI1AAWJ/+MiabwS3GagdGoABgF5H+mjvZvtCPQAEgENysFJ0DAgWAMLB+BnM+CBQAgsD+NfT5IFAACAIECgAgBIECAAhBoAAAUvzzJwIFgFDwzp8IFACCwTd/IlAAACkIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFgDhw8DA8BAoAUeDiccwIFABiwMkPgiBQAIgANz9Jh0ABIAIQKABEzDz5IVAAiJeZ9kOgABAts/XHRSQAiBQLE0iWMQFAnNg4AmchPQBEiZtTmLNBoADgPwgUAECKl/5EoAAQBD76E4ECQBh46E8ECgAgBYECAAhBoAAAQhAoAIAQBAoAIASBAgAIQaAAAELma+75h7d2u7e+6AVGoACwcWZr7tt3dhnf/0M3MAIFgI0zW3O3d699cfb0g91r33QCI1AA2DhzNffkVj73/Padq7/tBEagALBx5mru690Pyn/f7gRGoACwceZq7vbuF/m/D0qR7gMjUADYODM19/yD8tD9ya3qJOh3ShAoAGwcBAoAIMSeQDsLmTiEB4CtY38GWgVGoACwcRAoAIAQrsIDAAiZvw707da/+8AIFAA2DnciAQAImau53FVkHwAAE2lJREFU5x/sXuVeeACIktmae8rTmAAgUuZr7umHqT/f+qb7NgIFgK3DE+kBAIQgUAAAIQgUAEAIAgWA2EgSS4JCoAAQGUliy6AIFADiIkmsGRSBAkBUJIk9gyJQAIgKBAoAIASBAgAIQaAAAFK4iAQAIIVlTAAAUlhIDwCwNggUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAECIQ4ECAGyMpQQqNeh3vmO1uNuBitFAxeihbgaQVc5iAhXyne+snQNPoWI0UDF6qJsBrFQOAg0FKkYDFaOHuhkAgUYFFaOBitFD3QyAQKOCitFAxeihbgZAoFFBxWigYvRQNwMg0KigYjRQMXqomwG2KVAAgFBAoAAAQhAoAIAQBAoAIASBAgAIQaAAAEIQKACAEAQKACBkMYF++873/2Cw2Z//are7+tYXxYvnH97a7aoX+k+C5vkHu7cNNouuXkp63ab1Rqy18v9lBbqqKtHz//DTxqs468euavKAP9BG8Uygv9/lXP1tsUv+othP/0nYPLm1e+2b0a3iq5eSQYFGWivpd27JW72e82DXGOuR1o9V1WTc3oUi0Ae7qz8/O3v6QVGS27vXvsheZILRfxI4t7//P+9bSkeE9VIyJNBIa+Xbn+2u/vX/f3b2X/6D4ru3KdBI68euatLvq9u7UASafrX+otg2+/fJrXyPb99JBaP/JHC+fee1Pw00T0GE9VIxINBYa+V2bbqnP+t1nYZAY60fq6pJj+d/tvNKoNn5hd0//uusC9ze/eJP/6x58qUu+e3svODXZba/Tl/oPwmcB7u3G2X7xZNsdvFN8f6fbu1eLbp0hPVSURTwdlGgrHz70RFprZSDvfy7kF42yP/xz6uD+3K0R1o/dlWTvrX76dAUZ2mBlucX8hzd3v1zzcmXPO+3i2+A9mkd/SdhcjsdAVVxbu/+xa2qbh7s/sf07+5BVTz1UjEg0Jq4aqXluXqQZ7zdFmh7o2jqx65qzr5+9e8Ga2ZhgT7YXf279MWf8jO02bmFb87SidYvetvmU+nykOLJrb1H9J+ESV6CB6Uo0/p47YuyPh707RlTvdQYCDSuWqmOMAvyrvPk1u5/SsfRrhhgvbEeV/2cWVVNgUcCLUdC0QvKkzm3e4cO+YxaWSr9J2GSTyeqprpdfEF+vculqjgjFU+91BgINK5aaZ+qzI/nywPQ28UXb2+sx1U/Z1ZVU+CRQDP+y//7f/5sV5Qqz9fX3ewV8miUqnndVfNJmDz/oLwGmLdr+U9eUw8UE9B46mXPuEAjq5V2+bMyteak/bEeWf2cWVVN9bc/An36s/LMxC9aw6LJg1tXsw6h+FrQfxIoT27lRX9QraXIB0JePIVAI6qXPaMCja1W+jPQ1ju9sR5b/ZxZVU35wh+BPsnuoPgf/sX//YG+VF+X6u+XSv9JqHxdrYjO1dkWaLfNYqqXPWMCja5W+udAWzXS7TfR1c+ZVdUU+CPQtPV/kOXwub5Uv6+z3r00pv8kVMr7H/aXCgcEGlO9NBgRaIS10rsKPzQDjbB+7Kqm9bYK9wJ98ld5j89PL1RtXSxSVZTq+e3dq9X4qHpK8a/+k3CpG6ZYz1fWR15TnTaLq14ymt1GJ9D4auVMsQ5Ufw40tvpxoJqclQVaLPbNT+pVpXqwK1Zf9Up1u3Hqr32HhP6TcKm++MonipRFzOuj02Zx1UtGs9uUXSSbVLQEGl+tZKTDu1wPXt6J9HXjCklnJWNc9eNANWdFjDUF+jy/wzRt67fPynn183+/05Tq62bW041frW9Q1X8SLg0X5MVrLlZrt1lc9ZLT7DbZKPh5Vq62QCOslYy0PPW98K8WM65sHeify37TXIgTWf04UE3OyudAH+z2NwGUf7/277Ms9UrVOSf4dP+IFP0nAdNozidZ77+9+1/KO0o6bRZZvRQ0u01xh833/6/OrZwR1krG8w+r0r1VXfKoy/pkf/9ahPXjQDVF2HUvIj3JHq/306JVy7t2HxQzrk6pHuzaeX/6YdVJ9J+ES/PcVX50mt2weyu/p7nTZnHVS0Wz22TOePWLBy2BxlkrOd3ngVb3wqf8P/UjmmKsHweqOVtfoGDG7eYCFQDwHwTqDwgUIDAQqD8gUIDAQKD+gEABAgOB+gMCBQgMBAoAIASBAgAIQaAAAEIQKACAEAQKACAEgQIACEGgAABCECgAgBAECkFwlFRcvPzZ2pkBKEGgEAR7gaZcvq/Z6s53dZ8AuACBQhC0BJq8qPbkke4DADcgUAiCo+SFz/M/Tr96LzXoBc1GCBQWBYFCENQCTTlOkoP31RshUFgUBApB0BRodjyvnIIiUFgYBApB0BLos2vVq6/eO8wuzL+ZefO4OD96JXv/Ufb+AdfrwTEIFIKgJdDTd4tj+NOPqqtK5z9vCfS4ev+V1TIMUYBAIQhaAs0EebP455V07vnoenlIXx3Cp+9nk8/HH2FQcAsChSBQCTQ9ki9OhaZ/5OYsBfrwsDpFeqy52gRgBwQKQdATaHqkflLpMT2kzz8tBXpcb5t+oF7wBGAFBApBoDyE735aCLRpTa7Lg1MQKARBW6BHe4E+/urTX72UNAWaHtA3aO4GYBkECkGgvAp/duellicRKCwMAoUgaAn04WF1rJ4tAn3j1/eOOgLlxCcsAwKFIFDdiVSuYjrrnwPlxCcsAwKFIGgK9E5xL/xelNWdSUfVaqZq8RIuBbcgUAiC/dOY7r5ePo1pb8fj1jnQ6gj/LFvo1L5aD2AXBApBoHoeaHkI/9X1pHw8U7Zu/vRe/sH536SG/Vj75FAAKyBQCIKWQMszn8+uV0+o/7iYaZ4kSX12dPDJywB2QKAQBI3fRHrzXvXm6ScvZc9c+l194f3OYSrQzJmP3ssWOL38m9XyC3GAQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCXYLTd5PkxfvWwh3ZDAYAYhDoEjw8TJKD962FW1mgd767WOoLJgUgAIEuwXFy/npywVq4dQW6YOprFvTZtRc+N974xGLrjnH6yUtJkrz8m7GtXjnLKvCK6rN3G29/mX6516+OlduDHgS6AGmHvXCcTBiPIyDQBfBVoNnRTM75wewVOVILNA1R1+tJFgqBikGgC5B22JtpR71pKx4CXQBPBZp+Gb/4Wfrv3ZFDmiGBHr3wF/UJpePkAmdJZoBAF+AonX0+u2ZPBgh0ATwV6ElVJc+uDZ5VHxDos2sv3qnzy5xzHgjUPak7L2Q9terw6esr+Ymsc2/e170utqyP+796Lztwu1h83vdK8+Ojap9srpK98Sj78ODyZ9WbN9PJS3Lu/V7UdFbzerrhK/frVFt7nlVZSuqDvm7kC9m8KItQhEqKT4ripVuer0/bmWWpTqpbIa09VJm0QUegj96rC3SU3LzzUvXi7M5hcnCjFKh2I3sc1+o7qhqhkeaVcpNs2UeSbpm+8zCtqMut7nKSXKkKlx/Ap9ulb6XlOP9+qdO8cm8UW+ctee5NpqlqEKh7iqP39Di+tEDqg//ueuM8luJ1W6CnHyWt814dgbY/rs8VlAkeVx++km/7bvJG9iKN241aDLr0o/dKgbb3PKuyVAu0F/m/OSojfF6Gzr8y0uJ8rwxdZtswS0MCrfZQZ9IGbYGeFGceD27m1X8xqZI/K4r8Rq417UYWOelEbKfZF+ilw0bFFxylzXJUdJK9QLPtXrx/3GzYPFjVIstdJAsLBOqeo2rU1wdfaYf/p/fPHr1bdFLF67ZA0w6dzeoeXS/7cUeg7Y+L+e5ZNeU9LqYnjz8qFJONrPTtR79RRc1e5w6rUm3u2ShOkboichXgXHL53tnpx8XAzYqXv/6oTGhKlvKkFAJt7KHMZM1/NkG1Y0ug6ZdRUYKsStOKunA/m3nezAx0cOPs9CjPr3ajPv/IBGV50ro4ePOeLmOVQPeH8NkZ03YuHh6mlXqy/zLL9jkpHZu/SmN+L816XtVp+bLjhjs2V+FtCgTqnMpox9XUMDNK/lfpVMXrli9qJVbnUdsC7X5cfloESwfDhSpWNgYy99xU7lbPkI8LgXb3rCnjqyJfqYp3odyyzH79OtvQPEtDAq1n2epM1tgR6HFdggt1rnJdFc7KT1/oN+ojF2j+7ZIkL//6nipjfYH2c5FLsj6DWgm0eJm/Oq6+vW7We2YnTdTZiR0E6pxqaNeDfX89qTZM93XLF1XvzrpxedjYFGj34/L1w3zasV89VQzyKkR/t3rLNPnW63LPmqNqsqKLfJTUgzP7o4x3tj8ZbJqlAYGWe2gzOZ+mQGt/5BO3o+oL8ULtoexv7UaWOb1bnO/JTmx20+wLtJeL03fLqq2+Lq+c7S9NZa96snz8D39z3eIakm2BQF1TH7rXw76eaHVnmPvX3YtIJUcqgXY/Tne/We3b1Eq+1/5EQme3xpbd1530ilcDkY/aQtwXL9/QPEtDAq2rVJPJ+TQFWs/X8jcbntpfjLmg38gBX2XXHNNU9Gm2rsI3c/Hw8EKR4+pEd1eg7cv7j8qz8whUDQJ1Tb3wuT4vrzhEH3yd8/irT3/1UqIVaPvj+lRofv6xpuPF1m77RItUe3vWHO3PbKoj9wV65Wz/iXmWhgRaz+U1mZxPW6D1HLrtqYeHTYFqNnLDo2u57HRpagVaX3UrlFgJtDpvfuWse/I3OXj5J7/jEF4DAnXNcXOMK30wLtBsQUxDEl2Bdj7OJxe1vPS2au3mVKA3G5HNs+STQH2ZgTamh9mscfoMtFFl5dF9X6D7GWhW0+UJdQSqBIE6pj3Gq3U9kwRarEm5+Mav7ykP4Xsf5yOg1lx7AO9t1dmtseVx53WH0cijM1DDLBkJ1NnymqFzoA2B6s+BOhFow2QnxfmQkXOg3VzUS/4fHuZZ7wu0KcuqfI0vQWiBQB1z0rjT+KT41jcX6FG11PGV1tnFtkB7H2fDpozRO7+4t1VnN8U5UM05xfocqC7ykEDzMW+YJYVAj9oC1WdyPkNX4fdWGrgK7+YQfn9W56iXZvGiyIxOoEeVCcsnivQFWm3d/IJo9mJogkAdc9RYXlNejzYQaO2Hlsqq69ktgfY/zqYj1cK9ffLFdgr3dK+6l6+7ezZKVC6N0URWCHSf0pUpWWoItFkhraQ0mZyPYh3o4/d6yy3zxV/lClftRnazlRzcuJ/fgFSuCdunmWruRr6a+EJ1WaiXi0apjvMtFAIt1oHezVZxFIfw2YpeBKoGgbqlfQv8UX7m3uCQvdjnJGkL9Fh1DrT/cTZK/qIcEfsH7xR3KClstV/32V0H2tqzUYhqHag6skKgZeR6HahhltpLWusKaSSlzeR8Gudebupu+DmrTnGr7kRydBGpvix+UNxL1EizOAXywr8tbZ5WTS8XjfxU69x6Aq1O2+dFKv588WN350rCBoG6pX3sU9zwMXrR6Di/fyS/f7xxCP/V9eokqvIQfv9xcX/hzfrT7B706rag3vHyfrfj/p1IzT0b6R28f3pvILJCoNmUJrtp+8rULNVJNSukcbpBl8n5tAWqvuU8++fOS5p74V1dhT8t704vb0dqpHl2mv59/rMiM18eKgTaPL9ZnXfoC7R5L3z554nt6t0KCNQpaSdtLqorXo4KtLorPf3ezz+v5hyXPy4Gc+dOpO7H9UytjFlSTeYuaHY7Le9kP/+v6iWCzT1rTqrZiS5yX6CXyqVcVyZmqUqqUyHN6/aaTAIsAgJ1SvPRtRnHqmdj9JctFc9mulELNXt5cPl31cnA7sNEOh+3rttkU5TGE8wb7unv1n8ak/LZ53cOk2Jxiyay4iJSc5o0JUtVUu0Kaa0c1WQSYAkQKHSxfE9Py+YAmwKBQkHzOaJWz9shUNguCBQKjhtPOLIqPAQK2wWBQsHD7Mnq6fzzzqH1eyIRKGwVBAolJ/XPPdr9GQoECtsFgULF44+K69mW1wMhUNguCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhCBQAAAhCBQAQAgCBQAQgkABAIQgUAAAIQgUAEAIAgUAEIJAAQCEIFAAACEIFABACAIFABCCQAEAhPxXi+zlgH88CYwAAAAASUVORK5CYII=" width="672" /></p>
</div>
</div>
<div id="theres-a-lot-of-snow-in-london" class="section level1 unnumbered">
<h1>There’s a lot of snow in London</h1>
<p>The maximum snow depth in London is taller than a small cat, this is an illustration of what that might look like.</p>
<p><img src="data:image/png;base64,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" width="672" /></p>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
