<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>


<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Question 2" />




<meta name="author" content="Andrea Gauna" />

<meta name="date" content="2022-06-17" />

<meta name="description" content="Question 2">

<script id="pandoc-meta" type="application/json">
{"newpage_html_class":"page-break-after","bibliography":"Tex/ref.bib","date":"2022-06-17","csl":"Template/harvard-stellenbosch-university.csl","output":{"pagedown::html_paged":{"self_contained":true,"toc":true,"css":["Template/default-fonts-Texevier.css","Template/default-page-Texevier.css","Template/default-Texevier.css"],"csl":"Template/harvard-stellenbosch-university.csl","template":["Template/paged-Texevier.html"]}},"author":"Andrea Gauna","title":"Question 2"}
</script>

<title>Question 2</title>


<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>




<style type="text/css">@font-face {
font-family: 'Old Standard TT';
font-style: normal;
font-weight: 400;
src: url(data:font/ttf;base64,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IC5HI0cjYSBgsCBgZrACYiCwAFBYsEBgWWawAWMjICA8ijgtsD4sIyAuRrACJUawEENYUBtSWVggPFkusS4BFCstsD8sIyAuRrACJUawEENYUhtQWVggPFkusS4BFCstsEAsIyAuRrACJUawEENYUBtSWVggPFkjIC5GsAIlRrAQQ1hSG1BZWCA8WS6xLgEUKy2wQSywOCsjIC5GsAIlRrAQQ1hQG1JZWCA8WS6xLgEUKy2wQiywOSuKICA8sAQjQoo4IyAuRrACJUawEENYUBtSWVggPFkusS4BFCuwBEMusC4rLbBDLLAAFrAEJbAEJiAuRyNHI2GwCUMrIyA8IC4jOLEuARQrLbBELLEIBCVCsAAWsAQlsAQlIC5HI0cjYSCwBCNCsAlDKyCwYFBYILBAUVizAiADIBuzAiYDGllCQiMgR7AEQ7ACYiCwAFBYsEBgWWawAWNgILABKyCKimEgsAJDYGQjsANDYWRQWLACQ2EbsANDYFmwAyWwAmIgsABQWLBAYFlmsAFjYbACJUZhOCMgPCM4GyEgIEYjR7ABKyNhOCFZsS4BFCstsEUssQA4Ky6xLgEUKy2wRiyxADkrISMgIDywBCNCIzixLgEUK7AEQy6wListsEcssAAVIEewACNCsgABARUUEy6wNCotsEgssAAVIEewACNCsgABARUUEy6wNCotsEkssQABFBOwNSotsEossDcqLbBLLLAAFkUjIC4gRoojYTixLgEUKy2wTCywCCNCsEsrLbBNLLIAAEQrLbBOLLIAAUQrLbBPLLIBAEQrLbBQLLIBAUQrLbBRLLIAAEUrLbBSLLIAAUUrLbBTLLIBAEUrLbBULLIBAUUrLbBVLLMAAABBKy2wViyzAAEAQSstsFcsswEAAEErLbBYLLMBAQBBKy2wWSyzAAABQSstsFosswABAUErLbBbLLMBAAFBKy2wXCyzAQEBQSstsF0ssgAAQystsF4ssgABQystsF8ssgEAQystsGAssgEBQystsGEssgAARistsGIssgABRistsGMssgEARistsGQssgEBRistsGUsswAAAEIrLbBmLLMAAQBCKy2wZyyzAQAAQistsGgsswEBAEIrLbBpLLMAAAFCKy2waiyzAAEBQistsGssswEAAUIrLbBsLLMBAQFCKy2wbSyxADorLrEuARQrLbBuLLEAOiuwPistsG8ssQA6K7A/Ky2wcCywABaxADorsEArLbBxLLEBOiuwPistsHIssQE6K7A/Ky2wcyywABaxATorsEArLbB0LLEAOysusS4BFCstsHUssQA7K7A+Ky2wdiyxADsrsD8rLbB3LLEAOyuwQCstsHgssQE7K7A+Ky2weSyxATsrsD8rLbB6LLEBOyuwQCstsHsssQA8Ky6xLgEUKy2wfCyxADwrsD4rLbB9LLEAPCuwPystsH4ssQA8K7BAKy2wfyyxATwrsD4rLbCALLEBPCuwPystsIEssQE8K7BAKy2wgiyxAD0rLrEuARQrLbCDLLEAPSuwPistsIQssQA9K7A/Ky2whSyxAD0rsEArLbCGLLEBPSuwPistsIcssQE9K7A/Ky2wiCyxAT0rsEArLbCJLLMJBAIDRVghGyMhWUIrsAhlsAMkUHixBQEVRVgwWS0AAAAKAF3/EgGaAvoAAwAPABUAGQAjACkANQA5AD0ASAAZQBZDPjs6ODY0KigkIBoXFhIQCgQBAAowKwERIREXIxUzFSMVMzUjNTMHIxUzNSMnFSM1FyMVMxUjFTM1MxUjFSMVMxUjFTM1MxUjNSMVMxUjFTMnFSM1FyMVMwcVMzUjNzMBmv7D8KVBQqZCQkJkpkIiIYWmQkJkQiGFpmQiIWQhpqamIWSFpkZGpmZGIAL6/BgD6EMhJSEhJWBoIiQkJGEhJSFGG0IiFjgXL1BxPHFQLy9nIS8hIS8AAAIALgAAAuYCyAAeACEAWbUhAQgBAUpLsCpQWEAcAAgABQAIBWUAAQEpSwYEAgMAAANdBwEDAyoDTBtAHAABCAGDAAgABQAIBWUGBAIDAAADXQcBAwMtA0xZQAwRESUVIREjEiAJCB0rNzMyNxMzExYWMzMVITUzMjY1NCcnIwcGFRQWMzMVITczAy4lOxvXGdkKHBY4/spCDxQEL+oYDhYbPf7u1dRoIEkCX/2EGRMgIA8KDQmFQygSFiEg9AExAAMALgAAAuYDqgAKACkALABqQAoKAQIALAEJAgJKS7AqUFhAIQAAAgCDAAkABgEJBmUAAgIpSwcFAwMBAQRdCAEEBCoETBtAIQAAAgCDAAIJAoMACQAGAQkGZQcFAwMBAQRdCAEEBC0ETFlADisqESUVIREjEiYjCggdKwE3NjYzMhYVFAcHATMyNxMzExYWMzMVITUzMjY1NCcnIwcGFRQWMzMVITczAwFzXA0WDg0PHID+riU7G9cZ2QocFjj+ykIPFAQv6hgOFhs9/u7V1GgDBYUSDhEOFxVl/SZJAl/9hBkTICAPCg0JhUMoEhYhIPQBMQADAC4AAALmA5gADAArAC4AbUANDAkGBQQCAC4BCQICSkuwKlBYQCEAAAIAgwAJAAYBCQZlAAICKUsHBQMDAQEEXQgBBAQqBEwbQCEAAAIAgwACCQKDAAkABgEJBmUHBQMDAQEEXQgBBAQtBExZQA4tLBElFSERIxIqEgoIHSsTNjczFhcHJiYnBgYHAzMyNxMzExYWMzMVITUzMjY1NCcnIwcGFRQWMzMVITczA+5bLygvWwoaWx8fWxrKJTsb1xnZChwWOP7KQg8UBC/qGA4WGz3+7tXUaAMKNFpaNBAJOxwcOwn9JkkCX/2EGRMgIA8KDQmFQygSFiEg9AExAAQALgAAAuYDhgALABcANgA5AIy1OQEMBQFKS7AqUFhAKAIBAA4DDQMBBQABZwAMAAkEDAllAAUFKUsKCAYDBAQHXQsBBwcqB0wbQCsABQEMAQUMfgIBAA4DDQMBBQABZwAMAAkEDAllCggGAwQEB10LAQcHLQdMWUAkDAwAADg3NjU0Mi0sJyUkIyIgHRwaGAwXDBYSEAALAAokDwgVKwAmNTQ2MzIWFRQGIzImNTQ2MzIWFRQGIwEzMjcTMxMWFjMzFSE1MzI2NTQnJyMHBhUUFjMzFSE3MwMBEB4eFhcdHRe2Hh4WFx0dF/48JTsb1xnZChwWOP7KQg8UBC/qGA4WGz3+7tXUaAMeHhYXHR0XFh4eFhcdHRcWHv0CSQJf/YQZEyAgDwoNCYVDKBIWISD0ATEAAwAuAAAC5gOqAAoAKQAsAGtACwoJAgIALAEJAgJKS7AqUFhAIQAAAgCDAAkABgEJBmUAAgIpSwcFAwMBAQRdCAEEBCoETBtAIQAAAgCDAAIJAoMACQAGAQkGZQcFAwMBAQRdCAEEBC0ETFlADisqESUVIREjEiUkCggdKwEmNTQ2MzIWFxcHATMyNxMzExYWMzMVITUzMjY1NCcnIwcGFRQWMzMVITczAwEYHA8NDhYNXA3+liU7G9cZ2QocFjj+ykIPFAQv6hgOFhs9/u7V1GgDXxUXDhEOEoUL/SZJAl/9hBkTICAPCg0JhUMoEhYhIPQBMQAABAAuAAAC5gO0AAsAFwA2ADkAmLU5AQwFAUpLsCpQWEAuAAAAAgMAAmcOAQMNAQEFAwFnAAwACQQMCWUABQUpSwoIBgMEBAddCwEHByoHTBtAMQAFAQwBBQx+AAAAAgMAAmcOAQMNAQEFAwFnAAwACQQMCWUKCAYDBAQHXQsBBwctB0xZQCQMDAAAODc2NTQyLSwnJSQjIiAdHBoYDBcMFhIQAAsACiQPCBUrACY1NDYzMhYVFAYjNjY1NCYjIgYVFBYzATMyNxMzExYWMzMVITUzMjY1NCcnIwcGFRQWMzMVITczAwFkOjooKTk5KR8rKx8fKysf/qIlOxvXGdkKHBY4/spCDxQEL+oYDhYbPf7u1dRoAvA6KCk5OSkoOhgrHx8rKx8fK/0YSQJf/YQZEyAgDwoNCYVDKBIWISD0ATEAAAMALgAAAuYDigAVADQANwCJQAo3AQwFAUoLAQBIS7AqUFhALAAAAAMCAANnAAEAAgUBAmcADAAJBAwJZQAFBSlLCggGAwQEB10LAQcHKgdMG0AvAAUCDAIFDH4AAAADAgADZwABAAIFAQJnAAwACQQMCWUKCAYDBAQHXQsBBwctB0xZQBQ2NTQzMjArKiERIxIjIiUiIg0IHSsTNjYzMhcWMzI2NxcGBiMiJyYjIgYHAzMyNxMzExYWMzMVITUzMjY1NCcnIwcGFRQWMzMVITczA/ADLSYdPTEXEhYEFAMtJh09MRcSFgTWJTsb1xnZChwWOP7KQg8UBC/qGA4WGz3+7tXUaAMqJjYVERYUAiY2FREWFPz4SQJf/YQZEyAgDwoNCYVDKBIWISD0ATEAAgAaAAADsgLIAEEARADBtUQBBgEBSkuwKlBYQEkABgEDAQYDfgADBQEDBXwACggQCAoQfgAHDQANBwB+AAUACAoFCGUAEAANBxANZQQBAQECXQACAilLDgwJAwAAC10PAQsLKgtMG0BHAAYBAwEGA34AAwUBAwV8AAoIEAgKEH4ABw0ADQcAfgACBAEBBgIBZwAFAAgKBQhlABAADQcQDWUODAkDAAALXQ8BCwstC0xZQBxDQkFAPz04NzUzMjEwLykmIhESIzQREScgEQgdKzczMjY3ATY1NCYjIzUhFyM0JicmIyMiBhURMzI2NTMRIzQmIyMRFDMzMjY3PgI3MwMhNTMyNTUjBwYVFBYzMxUhNzMRGiAmLxABChELDikCLgQZERkqTJ8ODU0zLRoaLTNNG6AdPBUUGgoBGQz910Mb2CQSEBwv/vL6xyApIAH3HxQLCiD6FGAmQA0O/vNoO/6aO2j+2xsaGxxURQr+7CAbmUMiGhceIPQBeAADAD4AAAJ6AsgAGwAnADIAbLURAQcEAUpLsCpQWEAhCAEEAAcABAdlBQEBAQJdAAICKUsJBgIAAANdAAMDKgNMG0AfAAIFAQEEAgFlCAEEAAcABAdlCQYCAAADXQADAy0DTFlAFykoHRwvLSgyKTEkIRwnHScuISQgCggYKzczMjURNCYjIzUhMhYWFRQGBxUeAhUUBgYjIQEyNjU0JiMjIgYVERMyNjU0JiMjERQzPkgbDQ5IAUY7Zz5cPSlRNUBrQP6vAUJRO0w4cA4Nhz1PTz2HGyAbAlIODSAsTTFEWA0EAy1OMT1YLQGEU0c8Tg0O/vf+nElZWUn+1xsAAAEARv/uAl4C2gAlAIFLsCpQWEAxAAEEAwQBA34AAwYEAwZ8AAYFBAYFfAACAilLAAQEAF8AAAAxSwAFBQdfCAEHBzIHTBtAMgACAAQAAgR+AAEEAwQBA34AAwYEAwZ8AAYFBAYFfAAAAAQBAARnAAUFB18IAQcHNQdMWUAQAAAAJQAkEiQjERMjJgkIGysEJiY1NDY2MzIWFxYzMjY3NzMTIy4CIyIGFRQWMzI2NzMOAiMBEYZFRH5ULE4ZGAgIBwQTGQQcFkZTKV9PUmxgZQckAytqWBJsr2FlqGMoFxYKCzj+yl+BPqykqbOPZjt+XAAAAQBG/xICXgLaAD8AvUuwKlBYQEsABAcGBwQGfgAGCQcGCXwACQgHCQh8AAACAQIAAX4ACwACAAsCZwAFBSlLAAcHA18AAwMxSwAICApfAAoKMksAAQEMXw0BDAw2DEwbQEwABQMHAwUHfgAEBwYHBAZ+AAYJBwYJfAAJCAcJCHwAAAIBAgABfgADAAcEAwdnAAsAAgALAmcACAgKXwAKCjVLAAEBDF8NAQwMNgxMWUAYAAAAPwA+Ojg3NjMyJCMREyMoIyMkDggdKwQmNTQ2MzIXFhYzMjY1NCMjNy4CNTQ2NjMyFhcWMzI2NzczEyMuAiMiBhUUFjMyNjczDgIjBzMyFhUUBiMBSDwPDBoGAxwVHx5EMRFVej9EflQsThkYCAgHBBMZBBwWRlMpX09SbGBlByQDK2pYBx8nNzg+7iUhDBIjExYbFzRfCG+oXGWoYygXFgoLOP7KX4E+rKSps49mO35cJionKjsAAAIAPgAAAtoCyAATACIAS0uwKlBYQBgFAQEBAl0AAgIpSwYEAgAAA10AAwMqA0wbQBYAAgUBAQACAWUGBAIAAANdAAMDLQNMWUAPFRQdGhQiFSEmISQgBwgYKzczMjURNCYjIzUhMhYWFRQGBiMhJTI2NjU0JiMjIgYVERQzPkgbDQ5IAW5TilFRi1L+kgFqRlooYWeQDg0bIBsCUg4NIFmfZmamXiBflVaGuA0O/a4bAAACAD4AAALaAsgAFwAqAGVLsCpQWEAiCAECCQEBAAIBZQcBAwMEXQAEBClLCgYCAAAFXQAFBSoFTBtAIAAEBwEDAgQDZQgBAgkBAQACAWUKBgIAAAVdAAUFLQVMWUAVGRgnJiUkIR4YKhkpJiEjERIgCwgaKzczMjURIzUzETQmIyM1ITIWFhUUBgYjISUyNjY1NCYjIyIGFREzFSMRFDM+SBtdXQ0OSAFuU4pRUYtS/pIBakZaKGFnkA4Nc3MbIBsBKSQBBQ4NIFmfZmamXiBflVaGuA0O/vsk/tcbAAABAD4AAAJ4AsgALwCYS7AqUFhAPQAGAQMBBgN+AAMFAQMFfAAKCAcICgd+AAcACAcAfAAFAAgKBQhlBAEBAQJdAAICKUsJAQAAC10ACwsqC0wbQDsABgEDAQYDfgADBQEDBXwACggHCAoHfgAHAAgHAHwAAgQBAQYCAWUABQAICgUIZQkBAAALXQALCy0LTFlAEi8uLSwmIyIREiM0EREkIAwIHSs3MzI1ETQmIyM1IRcjNCYnJiMjIgYVETMyNjUzESM0JiMjERQzMzI2Nz4CNzMDIT5IGw0OSAIuBBkRGSpMnw4NTTMtGhotM00boB08FRQaCgEZDP3SIBsCUg4NIPoUYCZADQ7+82g7/po7aP7bGxobHFRFCv7sAAIAPgAAAngDqgAKADoAq7UKAQMAAUpLsCpQWEBCAAADAIMABwIEAgcEfgAEBgIEBnwACwkICQsIfgAIAQkIAXwABgAJCwYJZQUBAgIDXQADAylLCgEBAQxdAAwMKgxMG0BAAAADAIMABwIEAgcEfgAEBgIEBnwACwkICQsIfgAIAQkIAXwAAwUBAgcDAmUABgAJCwYJZQoBAQEMXQAMDC0MTFlAFDo5ODcxLiwqERIjNBERJCYjDQgdKwE3NjYzMhYVFAcHATMyNRE0JiMjNSEXIzQmJyYjIyIGFREzMjY1MxEjNCYjIxEUMzMyNjc+AjczAyEBV1wNFg4NDxyA/tpIGw0OSAIuBBkRGSpMnw4NTTMtGhotM00boB08FRQaCgEZDP3SAwWFEg4RDhcVZf0mGwJSDg0g+hRgJkANDv7zaDv+mjto/tsbGhscVEUK/uwAAgA+AAACeAOYAAwAPACvQAkMCQYFBAMAAUpLsCpQWEBCAAADAIMABwIEAgcEfgAEBgIEBnwACwkICQsIfgAIAQkIAXwABgAJCwYJZQUBAgIDXQADAylLCgEBAQxdAAwMKgxMG0BAAAADAIMABwIEAgcEfgAEBgIEBnwACwkICQsIfgAIAQkIAXwAAwUBAgcDAmYABgAJCwYJZQoBAQEMXQAMDC0MTFlAFDw7OjkzMC4sERIjNBERJCoSDQgdKxM2NzMWFwcmJicGBgcDMzI1ETQmIyM1IRcjNCYnJiMjIgYVETMyNjUzESM0JiMjERQzMzI2Nz4CNzMDIdJbLygvWwoaWx8fWxqeSBsNDkgCLgQZERkqTJ8ODU0zLRoaLTNNG6AdPBUUGgoBGQz90gMKNFpaNBAJOxwcOwn9JhsCUg4NIPoUYCZADQ7+82g7/po7aP7bGxobHFRFCv7sAAADAD4AAAJ4A4YACwAXAEcAyEuwKlBYQEkACgUHBQoHfgAHCQUHCXwADgwLDA4LfgALBAwLBHwCAQARAxADAQYAAWcACQAMDgkMZQgBBQUGXQAGBilLDQEEBA9dAA8PKg9MG0BHAAoFBwUKB34ABwkFBwl8AA4MCwwOC34ACwQMCwR8AgEAEQMQAwEGAAFnAAYIAQUKBgVlAAkADA4JDGUNAQQED10ADw8tD0xZQCoMDAAAR0ZFRD47OTc1NDMyMC4rKCQjIiEgHhoYDBcMFhIQAAsACiQSCBUrEiY1NDYzMhYVFAYjMiY1NDYzMhYVFAYjATMyNRE0JiMjNSEXIzQmJyYjIyIGFREzMjY1MxEjNCYjIxEUMzMyNjc+AjczAyH0Hh4WFx0dF7YeHhYXHR0X/mhIGw0OSAIuBBkRGSpMnw4NTTMtGhotM00boB08FRQaCgEZDP3SAx4eFhcdHRcWHh4WFx0dFxYe/QIbAlIODSD6FGAmQA0O/vNoO/6aO2j+2xsaGxxURQr+7AACAD4AAAJ4A6oACgA6AKy2CgkCAwABSkuwKlBYQEIAAAMAgwAHAgQCBwR+AAQGAgQGfAALCQgJCwh+AAgBCQgBfAAGAAkLBgllBQECAgNdAAMDKUsKAQEBDF0ADAwqDEwbQEAAAAMAgwAHAgQCBwR+AAQGAgQGfAALCQgJCwh+AAgBCQgBfAADBQECBwMCZQAGAAkLBgllCgEBAQxdAAwMLQxMWUAUOjk4NzEuLCoREiM0EREkJSQNCB0rEyY1NDYzMhYXFwcBMzI1ETQmIyM1IRcjNCYnJiMjIgYVETMyNjUzESM0JiMjERQzMzI2Nz4CNzMDIfwcDw0OFg1cDf7CSBsNDkgCLgQZERkqTJ8ODU0zLRoaLTNNG6AdPBUUGgoBGQz90gNfFRcOEQ4ShQv9JhsCUg4NIPoUYCZADQ7+82g7/po7aP7bGxobHFRFCv7sAAEAPgAAAnACyAAoAIhLsCpQWEA2AAYBAwEGA34AAwUBAwV8AAcIAAgHAH4ABQAIBwUIZQQBAQECXQACAilLCQEAAApdAAoKKgpMG0A0AAYBAwEGA34AAwUBAwV8AAcIAAgHAH4AAgQBAQYCAWUABQAIBwUIZQkBAAAKXQAKCi0KTFlAECgnJiQiERIjNBERJCALCB0rNzMyNRE0JiMjNSEXIzQmJyYjIyIGFREzMjY1MxEjNCYjIxEUFjMzFSE+SBsNDkgCLgQZERkqTJ8ODU0zLRoaLTNNDQ5Y/s4gGwJSDg0g+hRgJkANDv7zbTz+jjxt/uEPEiAAAQBG/+4CsgLaADsA9EuwJlBYQEAAAQQDBAEDfgADBwQDB3wACgYFBgoFfgAHCAEGCgcGZQACAilLAAQEAF8AAAAxSwAJCSpLAAUFC18MAQsLMgtMG0uwKlBYQEMAAQQDBAEDfgADBwQDB3wACgYFBgoFfgAJBQsFCQt+AAcIAQYKBwZlAAICKUsABAQAXwAAADFLAAUFC18MAQsLMgtMG0BEAAIABAACBH4AAQQDBAEDfgADBwQDB3wACgYFBgoFfgAJBQsFCQt+AAAABAEABGcABwgBBgoHBmUABQULXwwBCws1C0xZWUAWAAAAOwA6NjQxMCERJiYjERMjJg0IHSsEJiY1NDY2MzIWFxYzMjY3NzMTIy4CIyIGBhUUFhYzMjY2NTU0JiMjNSEVIyIGFREjNTQmIyIGBwYGIwEIf0NEflQsThkYCAgHBBMZBBwWRlMpRUwdHUxFJUQrDQ5vAUpJDg0gCAkLEAgXVDESZa1qZahjKBcWCgs4/spfgT5TlG9vlFM1UihaDg0gIA0O/txbEREQDiU/AAABAD4AAALqAsgAKwBsS7AqUFhAJQAEAAsABAtlBwUDAwEBAl0GAQICKUsMCggDAAAJXQ0BCQkqCUwbQCMGAQIHBQMDAQQCAWUABAALAAQLZQwKCAMAAAldDQEJCS0JTFlAFisqKSclJCIgHx4jIREiEiERIyAOCB0rNzMyNRE0IyM1IRUjIhURIRE0IyM1IRUjIhURFDMzFSE1MzI1ESERFDMzFSE+SBsbSAEiSBsBLhtIASJIGxtI/t5IG/7SG0j+3iAbAlIbICAb/vkBBxsgIBv9rhsgIBsBK/7VGyAAAAEAPgAAAWACyAAVAENLsCpQWEAXAwEBAQJdAAICKUsEAQAABV0ABQUqBUwbQBUAAgMBAQACAWUEAQAABV0ABQUtBUxZQAkRJCERJCAGCBorNzMyNRE0JiMjNSEVIyIGFREUMzMVIT5IGw0OSAEiSA4NG0j+3iAbAlIODSAgDQ79rhsgAAIAPgAAAWADqgAKACAAVbUKAQMAAUpLsCpQWEAcAAADAIMEAQICA10AAwMpSwUBAQEGXQAGBioGTBtAGgAAAwCDAAMEAQIBAwJlBQEBAQZdAAYGLQZMWUAKESQhESQmIwcIGysTNzY2MzIWFRQHBwMzMjURNCYjIzUhFSMiBhURFDMzFSG3XA0WDg0PHICGSBsNDkgBIkgODRtI/t4DBYUSDhEOFxVl/SYbAlIODSAgDQ79rhsgAAACADIAAAFuA5gADAAiAFlACQwJBgUEAwABSkuwKlBYQBwAAAMAgwQBAgIDXQADAylLBQEBAQZdAAYGKgZMG0AaAAADAIMAAwQBAgEDAmUFAQEBBl0ABgYtBkxZQAoRJCERJCoSBwgbKxM2NzMWFwcmJicGBgcTMzI1ETQmIyM1IRUjIgYVERQzMxUhMlsvKC9bChpbHx9bGgJIGw0OSAEiSA4NG0j+3gMKNFpaNBAJOxwcOwn9JhsCUg4NICANDv2uGyAAAwA2AAABagOGAAsAFwAtAHBLsCpQWEAjAgEACwMKAwEGAAFnBwEFBQZdAAYGKUsIAQQECV0ACQkqCUwbQCECAQALAwoDAQYAAWcABgcBBQQGBWUIAQQECV0ACQktCUxZQB4MDAAALSwrKSUjIiEgHhoYDBcMFhIQAAsACiQMCBUrEiY1NDYzMhYVFAYjMiY1NDYzMhYVFAYjAzMyNRE0JiMjNSEVIyIGFREUMzMVIVQeHhYXHR0Xth4eFhcdHRf4SBsNDkgBIkgODRtI/t4DHh4WFx0dFxYeHhYXHR0XFh79AhsCUg4NICANDv2uGyAAAgA+AAABYAOqAAoAIABWtgoJAgMAAUpLsCpQWEAcAAADAIMEAQICA10AAwMpSwUBAQEGXQAGBioGTBtAGgAAAwCDAAMEAQIBAwJlBQEBAQZdAAYGLQZMWUAKESQhESQlJAcIGysTJjU0NjMyFhcXBwMzMjURNCYjIzUhFSMiBhURFDMzFSFcHA8NDhYNXA2eSBsNDkgBIkgODRtI/t4DXxUXDhEOEoUL/SYbAlIODSAgDQ79rhsgAAEALP/uAfwCyAAmAFhLsCpQWEAfAAACAQIAAX4EAQICA10AAwMpSwABAQVgBgEFBTIFTBtAHQAAAgECAAF+AAMEAQIAAwJlAAEBBWAGAQUFNQVMWUAOAAAAJgAlIRElKiUHCBkrFiY1NDY2MzIWFRQGBwYGFRQWMzI2NRE0JiMjNSEVIyIGFREUBgYjjGAaJxIdHBcZEQ9ALjE2DQ5IASJIDg02WTQSTEMeKhUdFRUXCAUODx8lTDUB/g4NICANDv41QmAyAAEAPgAAAsoCyAA2AGNACTAvHxAEAAEBSkuwKlBYQB0GBAMDAQECXQUBAgIpSwoJBwMAAAhdCwEICCoITBtAGwUBAgYEAwMBAAIBZwoJBwMAAAhdCwEICC0ITFlAEjY1NDIpJxElIREpIREkIAwIHSs3MzI1ETQmIyM1IRUjIgYVETc2NjU0JiMjNSEVIyIHBxMWFjMzFSE1MzI2NTQmJwMHFRQzMxUhPkgbDQ5IAR1DDg3mDQwaExsBCCghOajMDSAeIf7SQwsQBAOjUxtD/uMgGwJSDg0gIA0O/srrDhwSEhggIDuq/okZEyAgDQgGDwQBMlTxGyAAAQA+AAACZALIAB0ASrUbAQABAUpLsCpQWEAXAwEBAQJdAAICKUsEAQAABV0ABQUqBUwbQBUAAgMBAQACAWUEAQAABV0ABQUtBUxZQAkYNCERJCAGCBorNzMyNRE0JiMjNSEVIyIGFREUMzMyNjc+AjczAyE+SBsNDkgBMlgODRtlNVQVEBUKARkJ/eMgGwJSDg0gIA0O/a4bMC4iTTYH/tYAAgA+AAACZALIAB0AKQCOtRsBAAcBSkuwKlBYQCIDAQEBAl0AAgIpSwgBBwcGXwAGBixLBAEAAAVdAAUFKgVMG0uwMlBYQCAAAgMBAQYCAWUIAQcHBl8ABgYsSwQBAAAFXQAFBS0FTBtAHgACAwEBBgIBZQAGCAEHAAYHZwQBAAAFXQAFBS0FTFlZQBAeHh4pHiglGDQhESQgCQgbKzczMjURNCYjIzUhFSMiBhURFDMzMjY3PgI3MwMhACY1NDYzMhYVFAYjPkgbDQ5IATJYDg0bZTVUFRAVCgEZCf3jAcAeHhYXHR0XIBsCUg4NICANDv2uGzAuIk02B/7WAVYeFhcdHRcWHgAAAQA+//QDHALIACkAZbcnFQADAAMBSkuwKlBYQCAGAQMDBF0FAQQEKUsJBwIDAAABXQgBAQEqSwAKCioKTBtAHgAKAQqEBQEEBgEDAAQDZQkHAgMAAAFdCAEBAS0BTFlAECkoJSMRJCESESUhESQLCB0rEyMRFBYzMxUjNTMyNjURNCYjIzUzExMzFSMiBhURFDMzFSE1MzI1EQMjzwYjHCTuJBwjDQ5I1KOYz0gODRtI/t5IG7cYAm7+AiUrICArJQIdDg0g/dkCJyANDv2uGyAgGwJO/WsAAQA+/+4C4gLIACMAhLcVDgADAAMBSkuwG1BYQB4HBQIDAwRdBgEEBClLAgEAAAFdAAEBKksACAgqCEwbS7AqUFhAHgAIAQiEBwUCAwMEXQYBBAQpSwIBAAABXQABASoBTBtAHAAIAQiEBgEEBwUCAwAEA2cCAQAAAV0AAQEtAUxZWUAMEyERJBElIREkCQgdKxMjERQWMzMVIzUzMjY1ESYmIyM1MwERNCYjIzUzFSMiBhURI80EIxwk7iQdIgEMDki9AVsiHCTuJBwkKAJb/hUlKyAgKyUCHQ4NIP3SAb4lKyAgKyX9lgAAAgA+/+4C4gOKABUAOQDBQAwrJBYDBAcBSgsBAEhLsBtQWEAuAAAAAwIAA2cAAQACCAECZwsJAgcHCF0KAQgIKUsGAQQEBV0ABQUqSwAMDCoMTBtLsCpQWEAuAAwFDIQAAAADAgADZwABAAIIAQJnCwkCBwcIXQoBCAgpSwYBBAQFXQAFBSoFTBtALAAMBQyEAAAAAwIAA2cAAQACCAECZwoBCAsJAgcECAdnBgEEBAVdAAUFLQVMWVlAFDk4NTMyMTAuESUhESciJSIiDQgdKwE2NjMyFxYzMjY3FwYGIyInJiMiBgcHIxEUFjMzFSM1MzI2NREmJiMjNTMBETQmIyM1MxUjIgYVESMBBAMtJh09MRcSFgQUAy0mHT0xFxIWBEsEIxwk7iQdIgEMDki9AVsiHCTuJBwkKAMqJjYVERYUAiY2FREWFM3+FSUrICArJQIdDg0g/dIBviUrICArJf2WAAACAEb/7gKKAtoADwAbAExLsCpQWEAXAAICAF8AAAAxSwUBAwMBXwQBAQEyAUwbQBUAAAACAwACZwUBAwMBXwQBAQE1AUxZQBIQEAAAEBsQGhYUAA8ADiYGCBUrBCYmNTQ2NjMyFhYVFAYGIzY2NTQmIyIGFRQWMwEUhEpKhFRUhEpKhFRiVlZiYlZWYhJqrV9frWpqrV9frWogs6OksrKko7MAAAMARv/uAooDqgAKABoAJgBetQoBAQABSkuwKlBYQBwAAAEAgwADAwFfAAEBMUsGAQQEAl8FAQICMgJMG0AaAAABAIMAAQADBAEDZwYBBAQCXwUBAgI1AkxZQBMbGwsLGyYbJSEfCxoLGSwjBwgWKwE3NjYzMhYVFAcHAiYmNTQ2NjMyFhYVFAYGIzY2NTQmIyIGFRQWMwFPXA0WDg0PHIBIhEpKhFRUhEpKhFRiVlZiYlZWYgMFhRIOEQ4XFWX89GqtX1+tamqtX1+taiCzo6SysqSjswADAEb/7gKKA5gADAAcACgAY0AJDAkGBQQBAAFKS7AqUFhAHAAAAQCDAAMDAV8AAQExSwYBBAQCXwUBAgIyAkwbQBoAAAEAgwABAAMEAQNoBgEEBAJfBQECAjUCTFlAFB0dDQ0dKB0nIyENHA0bFRMSBwgVKxM2NzMWFwcmJicGBgcSJiY1NDY2MzIWFhUUBgYjNjY1NCYjIgYVFBYzylsvKC9bChpbHx9bGkCESkqEVFSESkqEVGJWVmJiVlZiAwo0Wlo0EAk7HBw7Cfz0aq1fX61qaq1fX61qILOjpLKypKOzAAAEAEb/7gKKA4YACwAXACcAMwB0S7AqUFhAIwIBAAkDCAMBBAABZwAGBgRfAAQEMUsLAQcHBV8KAQUFMgVMG0AhAgEACQMIAwEEAAFnAAQABgcEBmcLAQcHBV8KAQUFNQVMWUAiKCgYGAwMAAAoMygyLiwYJxgmIB4MFwwWEhAACwAKJAwIFSsSJjU0NjMyFhUUBiMyJjU0NjMyFhUUBiMCJiY1NDY2MzIWFhUUBgYjNjY1NCYjIgYVFBYz7B4eFhcdHRe2Hh4WFx0dF7qESkqEVFSESkqEVGJWVmJiVlZiAx4eFhcdHRcWHh4WFx0dFxYe/NBqrV9frWpqrV9frWogs6OksrKko7MAAAMARv/uAooDqgAKABoAJgBftgoJAgEAAUpLsCpQWEAcAAABAIMAAwMBXwABATFLBgEEBAJfBQECAjICTBtAGgAAAQCDAAEAAwQBA2cGAQQEAl8FAQICNQJMWUATGxsLCxsmGyUhHwsaCxkrJAcIFisTJjU0NjMyFhcXBwImJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjP0HA8NDhYNXA1ghEpKhFRUhEpKhFRiVlZiYlZWYgNfFRcOEQ4ShQv89GqtX1+tamqtX1+taiCzo6SysqSjswADAEb/7gKKAtoAGQAhACkAXkAYDQECACcmIRgOCwEHAwICSgwBAEgZAQFHS7AqUFhAFgACAgBfAAAAMUsEAQMDAV8AAQEyAUwbQBQAAAACAwACZwQBAwMBXwABATUBTFlADCIiIikiKCUrJwUIFys3NyYmNTQ2NjMyFhc3FwcWFhUUBgYjIiYnBwEmIyIGFRQXBDY1NCcBFjNGSyQnSYVUN2AmQyBKJSdKhFQ3YSZEAZgsamJWEgEIVhP+xC1qBmM0g0RfrWovKlkYYjSDRV+tai8rWgJfbbKka06ds6NvTP5dbgADAEb/7gKKA4oAFQAlADEAdbMLAQBIS7AqUFhAJwAAAAMCAANnAAEAAgQBAmcABgYEXwAEBDFLCQEHBwVfCAEFBTIFTBtAJQAAAAMCAANnAAEAAgQBAmcABAAGBwQGZwkBBwcFXwgBBQU1BUxZQBYmJhYWJjEmMCwqFiUWJCkiJSIiCggZKxM2NjMyFxYzMjY3FwYGIyInJiMiBgcSJiY1NDY2MzIWFhUUBgYjNjY1NCYjIgYVFBYzzAMtJh09MRcSFgQUAy0mHT0xFxIWBDSESkqEVFSESkqEVGJWVmJiVlZiAyomNhURFhQCJjYVERYU/MZqrV9frWpqrV9frWogs6OksrKko7MAAAIARv/uA94C2gA1AEIAykuwKlBYQFEABQMCAwUCfgACBAMCBHwACQcGBwkGfgAGCAcGCHwABAAHCQQHZQAMDABfAAAAMUsAAwMBXQABASlLAAgICl0ACgoqSw8BDQ0LXw4BCwsyC0wbQE0ABQMCAwUCfgACBAMCBHwACQcGBwkGfgAGCAcGCHwAAAAMAwAMZwABAAMFAQNlAAQABwkEB2UACAgKXQAKCi1LDwENDQtfDgELCzULTFlAHjY2AAA2QjZBPTsANQA0MjAvLjIiERIjNBEiJhAIHSsEJiY1NDY2MzIXFjMhFyM0JicmIyMiBhURMzI2NTMRIzQmIyMRFDMzMjY3PgI3MwMhIgcGIzY2NRE0JiMiBhUUFjMBFIVJSYVUDyAuQQHMBBkRGSpMnw4NTTMtGhotM00boB08FRQaCgEZDP41Qi4gD0xTTFNiVlZiEmqtX1+tagYM+hRgJkANDv7zaDv+mjto/tsbGhscVEUK/uwMBiBaTQFdT1mypKOzAAACAD4AAAJ8AsgAGgAmAF1LsCpQWEAgCAEGAAMABgNlBwEBAQJdAAICKUsEAQAABV0ABQUqBUwbQB4AAgcBAQYCAWUIAQYAAwAGA2UEAQAABV0ABQUtBUxZQBEcGyMgGyYcJhEjJiEkIAkIGis3MzI1ETQmIyM1ITIWFhUUBgYjIxEUFjMzFSEBMjY1NCYjIyIGFRE+SBsNDkgBTkZtPT1tRo8MD1j+zgFbNkNCN4EODSAbAlIODSAvVTY3VjH+6w4NIAFwXUFBWQ0O/uMAAAIAPgAAAnwCyAAgACwAb0uwKlBYQCgABAAJCAQJZQoBCAAFAAgFZQMBAQECXQACAilLBgEAAAddAAcHKgdMG0AmAAIDAQEEAgFlAAQACQgECWUKAQgABQAIBWUGAQAAB10ABwctB0xZQBMiISkmISwiLBEiJiMhESQgCwgcKzczMjURNCYjIzUhFSMiBhUVMzIWFhUUBgYjIxUUMzMVISUyNjU0JiMjIgYVET5IGw0OSAEyWA4Nj0ZtPT1tRo8bWP7OAVs2Q0I3gQ4NIBsCUg4NICANDkMvVTY3VjGXGyDyXUFBWQ0O/uMAAAMARv9YAooC2gAdADIAPACSQA8mAQMHNBMCCAMCAQAIA0pLsCpQWEAuAAMHCAcDCH4ABQAHAwUHZwACCQEEAgRjAAYGAV8AAQExSwoBCAgAXwAAADIATBtALAADBwgHAwh+AAEABgUBBmcABQAHAwUHZwACCQEEAgRjCgEICABfAAAANQBMWUAZMzMAADM8Mzs4Ni0rJCIAHQAcEigmIwsIGCsEJicGIyImJjU0NjYzMhYWFRQGBxYWMzI2NTMUBiMlJjU0NjMyFhc2NjU0JiMiBhUUFhcWNyYmIyIGFRQzAdswBSQaVIVJSoRUVIRKVVALJyAmGhMvRP7yBTgpLzgNJiFVY2NVJDSAGwMaJBoiQqhaRgpsrmBfq2hoq19tuDA0P1FBZXXXDBAqNjwwJ5Ruo6+vo2emLSALMz8jHjwAAgA+//QCrALIAC4AOgCStSABAAkBSkuwKlBYQDMABwAGAAcGfgwBCQAABwkAZQoBBAQFXQAFBSlLAwEBAQJdAAICKksABgYIXwsBCAg1CEwbQDEABwAGAAcGfgAFCgEECQUEZQwBCQAABwkAZQMBAQECXQACAi1LAAYGCF8LAQgINQhMWUAZMC8AADc0LzowOgAuAC0RLCEkIREjJg0IHCsEJicmJyYmIyMRFBYzMxUhNTMyNRE0JiMjNSEyFhUUBgcVFhYXHgIzMjUzFAYjAzI2NTQmIyMiBhUVAiMtDRsCAS4zbQwPWf7NSBsNDkgBSGF8b045SQwHCxERKxkmQuZUR0E4aA4NDBYZNH1DWf7LDg0gIBsCUg4NIEpWSloIBAtTZDk0FWxBawGcUUc9Qw0O/QABAFj/7gI4AtoAOADlS7AqUFhAPQAFCAcIBQd+AAcCCAcCfAACAAgCAHwAAAMIAAN8AAYGKUsACAgEXwAEBDFLAAEBKksAAwMJXwoBCQkyCUwbS7AyUFhAPgAGBAgEBgh+AAUIBwgFB34ABwIIBwJ8AAIACAIAfAAAAwgAA3wABAAIBQQIZwABAS1LAAMDCV8KAQkJNQlMG0BBAAYECAQGCH4ABQgHCAUHfgAHAggHAnwAAgAIAgB8AAADCAADfAABAwkDAQl+AAQACAUECGcAAwMJXwoBCQk1CUxZWUASAAAAOAA3IxESIysjERIjCwgdKwQmJyYjIgcHIwMzHgIzMjY1NCYnJyYmNTQ2MzIXFhYzMjc3MxMjLgIjIgYVFBYXFxYWFRQGBiMBNVEeKggUBgQXBxgGR2o4Uks5N5hPS3BUQlAKFAgRAwQYChgQRVwxOEguLcFDQy9hSRIlFiArKAE8SodTUDgxOBY9IGVHYFw8BwsYJP78SHA+SUEtMhJNG2Q3NV47AAEASAAAApYCyAAhAFdLsCpQWEAgBAECAQABAgB+BQEBAQNdAAMDKUsGAQAAB10ABwcqB0wbQB4EAQIBAAECAH4AAwUBAQIDAWcGAQAAB10ABwctB0xZQAsRJDQRERQ0IAgIHCs3MzI1ETQmIyMiBwYGFSMTIRMjNCYnJiMjIgYVERQzMxUhxmAbDA8kPy4dFBwIAj4IHBQdLj8kDwwbYP6uIBsCVQ4NQCl7HQEe/uIdeylADQ79qxsgAAEANP/uAvACyAAoAFBLsCpQWEAaBgQCAwAAAV0FAQEBKUsAAwMHXwgBBwcyB0wbQBgFAQEGBAIDAAMBAGcAAwMHXwgBBwc1B0xZQBAAAAAoACchESYlIREmCQgbKwQmJjURNCYjIzUhFSMiBhURFBYzMjY2NRE0JiMjNTMVIyIGFREUBgYjAUR2Nw0OSAEjSQ4NWlE/Wi4kHCPuIxwkOW1JEkdzRQGgDg0gIA0O/kVdZzNUMQGRJSwgICwl/nk/ZzwAAgA0/+4C8AOqAAoAMwBitQoBAgABSkuwKlBYQB8AAAIAgwcFAwMBAQJdBgECAilLAAQECF8JAQgIMghMG0AdAAACAIMGAQIHBQMDAQQCAWcABAQIXwkBCAg1CExZQBELCwszCzIhESYlIREsIwoIHCsBNzY2MzIWFRQHBwImJjURNCYjIzUhFSMiBhURFBYzMjY2NRE0JiMjNTMVIyIGFREUBgYjAYNcDRYODQ8cgEx2Nw0OSAEjSQ4NWlE/Wi4kHCPuIxwkOW1JAwWFEg4RDhcVZfz0R3NFAaAODSAgDQ7+RV1nM1QxAZElLCAgLCX+eT9nPAAAAgA0/+4C8AOYAAwANQBtQAkMCQYFBAIAAUpLsCpQWEAfAAACAIMHBQMDAQECXQYBAgIpSwAEBAhfCQEICDIITBtAHQAAAgCDBgECBwUDAwEEAgFnAAQECF8JAQgINQhMWUAYDQ0NNQ00LiwrKiknIR8aGBcWFRMSCggVKxM2NzMWFwcmJicGBgcSJiY1ETQmIyM1IRUjIgYVERQWMzI2NjURNCYjIzUzFSMiBhURFAYGI/5bLygvWwoaWx8fWxo8djcNDkgBI0kODVpRP1ouJBwj7iMcJDltSQMKNFpaNBAJOxwcOwn89EdzRQGgDg0gIA0O/kVdZzNUMQGRJSwgICwl/nk/ZzwAAwA0/+4C8AOGAAsAFwBAAH5LsCpQWEAmAgEADQMMAwEFAAFnCggGAwQEBV0JAQUFKUsABwcLXw4BCwsyC0wbQCQCAQANAwwDAQUAAWcJAQUKCAYDBAcFBGcABwcLXw4BCws1C0xZQCYYGAwMAAAYQBg/OTc2NTQyLColIyIhIB4MFwwWEhAACwAKJA8IFSsAJjU0NjMyFhUUBiMyJjU0NjMyFhUUBiMCJiY1ETQmIyM1IRUjIgYVERQWMzI2NjURNCYjIzUzFSMiBhURFAYGIwEgHh4WFx0dF7YeHhYXHR0XvnY3DQ5IASNJDg1aUT9aLiQcI+4jHCQ5bUkDHh4WFx0dFxYeHhYXHR0XFh780EdzRQGgDg0gIA0O/kVdZzNUMQGRJSwgICwl/nk/ZzwAAAIANP/uAvADqgAKADMAY7YKCQICAAFKS7AqUFhAHwAAAgCDBwUDAwEBAl0GAQICKUsABAQIXwkBCAgyCEwbQB0AAAIAgwYBAgcFAwMBBAIBZwAEBAhfCQEICDUITFlAEQsLCzMLMiERJiUhESskCggcKwEmNTQ2MzIWFxcHAiYmNRE0JiMjNSEVIyIGFREUFjMyNjY1ETQmIyM1MxUjIgYVERQGBiMBKBwPDQ4WDVwNZHY3DQ5IASNJDg1aUT9aLiQcI+4jHCQ5bUkDXxUXDhEOEoUL/PRHc0UBoA4NICANDv5FXWczVDEBkSUsICAsJf55P2c8AAEALP/uAuwCyAAeAGq1DgEGAAFKS7AbUFhAFAUDAgMAAAFdBAEBASlLAAYGKgZMG0uwKlBYQBQABgAGhAUDAgMAAAFdBAEBASkATBtAGgAGAAaEBAEBAAABVQQBAQEAXwUDAgMAAQBPWVlAChMhESohESIHCBsrEyYmIyM1IRUjIgYVFBcTEzY1NCYjIzUhFSMiBgcDI6YJHBY/AUBCDhQEq4QMFxw2AQ4lIyYLyxkCfBkTICAPCgsL/h8BliceFSAgICkg/Y8AAQAm/+4EFALIADEAgkAKLx0PDgsFCQABSkuwG1BYQBgIBgUDAgUAAAFdBwQCAQEpSwoBCQkqCUwbS7AqUFhAGAoBCQAJhAgGBQMCBQAAAV0HBAIBASkATBtAHwoBCQAJhAcEAgEAAAFVBwQCAQEAXwgGBQMCBQABAE9ZWUAQMTAuLSERKiERKSERIgsIHSsTJiYjIzUhFSMiBhUUFxMTJyYmIyM1IRUjIhUUFxMTNjY1NCYjIzUhFSMiBgcDIwMDI58JHBY+ASgwDhQEhXkKByoWHQEoJzMGfnwHBSMfIgEOKyIlCscZpJ4ZAnwZEyAgDwoIDv40AbYgFBEgIDQOEf5PAYobHRUTGiAgKCH9jwIs/dQAAQAuAAAC1ALIADwAZUALMy8jFBAFBgABAUpLsCpQWEAdBgQDAwEBAl0FAQICKUsKCQcDAAAIXQsBCAgqCEwbQBsFAQIGBAMDAQACAWcKCQcDAAAIXQsBCAgtCExZQBI8Ozo4LSsRJiERKiERJiAMCB0rNzMyNjc3AyYmIyM1IRUjIhUUFhcXNzY1NCYjIzUhFSMiBgcHExYWMzMVITUzMjY1NCYnJwcGFRQWMzMVIS4fIS0VqZUPHyE9ATY8EgQEbF8UGxYfAQ4tHikRmbEOHBQ+/so8Dg0EA4BzGRISNv7yICMg/QEUHBggIA8GDgbIjh4bERkgIBca5v67GRMgIAwJBg4F7K8mGRIaIAAAAQAqAAACvgLIACkAVbcjEwQDAAEBSkuwKlBYQBoGBAMDAQECXQUBAgIpSwcBAAAIXQAICCoITBtAGAUBAgYEAwMBAAIBZwcBAAAIXQAICC0ITFlADBElIRErIRElIAkIHSs3MzI1EQMmJiMjNSEVIyIGFRQXEzc2NjU0JiMjNTMVIyIGBwMRFDMzFSHgYBvCDxgUNAE2PA8UBZ5mBQwbHB74HSAoE48bYP6uIBsBAwE+GhIgIA4LDwf+9cQHKgwYISAgJyL+8P7sGyAAAgAqAAACvgOqAAoANABmQAwKAQMALh4PAwECAkpLsCpQWEAfAAADAIMHBQQDAgIDXQYBAwMpSwgBAQEJXQAJCSoJTBtAHQAAAwCDBgEDBwUEAwIBAwJnCAEBAQldAAkJLQlMWUAONDMlIRErIRElJiMKCB0rATc2NjMyFhUUBwcDMzI1EQMmJiMjNSEVIyIGFRQXEzc2NjU0JiMjNTMVIyIGBwMRFDMzFSEBb1wNFg4NDxyAnGAbwg8YFDQBNjwPFAWeZgUMGxwe+B0gKBOPG2D+rgMFhRIOEQ4XFWX9JhsBAwE+GhIgIA4LDwf+9cQHKgwYISAgJyL+8P7sGyAAAAEARAAAAl4CyAAZAE1ADxcKAgIAAUoNAQAAAQICSUuwKlBYQBUAAAABXQABASlLAAICA10AAwMqA0wbQBMAAQAAAgEAZQACAgNdAAMDLQNMWbYYIhghBAgYKzcBIyIGBw4CFSMTIRUBMzI2Nz4CNTMDIUQBnrwhORMYIBAZGAHc/mbIIkgXGSEQGRD99iACiCQWHEk9BAEAIP14KSAkV0YE/tIAAgAu//QB3AHUADMAPgBXQFQ3NgcDBAEvAQMEAkoAAQAEAAEEfgAEAwAEA3wAAAACXwACAjRLAAMDBV8IBgIFBTVLCQEHBwVfCAYCBQU1BUw0NAAAND40PQAzADIiEiQlLCkKCBorFiY1NDY2Nzc1NCMiBhUUFxYWFxYWFRQGIyImNTQ2NjMyFhUVFDMyNjUzFAYjIiYnJwYGIzY2NzUHBgYVFBYze000RTFcXSI4AwIJBBITGRMWJClBIkJgHxkWEiMtKysCBQ9DLT0zFFcwKyYYDDRCMzoZCRFVXSMWCgUDBgEFEhAVEiIgJTYbRUn2MjoqPFIzLQIjPyRHN18TCjs2LiEAAAMALv/0AdwCrAAKAD4ASQCmQBAKAQMAQkESAwUCOgEEBQNKS7AjUFhAOAACAQUBAgV+AAUEAQUEfAAAACtLAAEBA18AAwM0SwAEBAZfCQcCBgY1SwoBCAgGXwkHAgYGNQZMG0A4AAADAIMAAgEFAQIFfgAFBAEFBHwAAQEDXwADAzRLAAQEBl8JBwIGBjVLCgEICAZfCQcCBgY1BkxZQBY/PwsLP0k/SAs+Cz0iEiQlLC8jCwgbKxM3NjYzMhYVFAcHAiY1NDY2Nzc1NCMiBhUUFxYWFxYWFRQGIyImNTQ2NjMyFhUVFDMyNjUzFAYjIiYnJwYGIzY2NzUHBgYVFBYzy1wNFg4NDxyAXU00RTFcXSI4AwIJBBITGRMWJClBIkJgHxkWEiMtKysCBQ9DLT0zFFcwKyYYAgeFEg4RDhcVZf34NEIzOhkJEVVdIxYKBQMGAQUSEBUSIiAlNhtFSfYyOio8UjMtAiM/JEc3XxMKOzYuIQAAAwAu//QB3AKgAAoAPgBJAGpAZwoIBgUEAwBCQRIDBQI6AQQFA0oAAAMAgwACAQUBAgV+AAUEAQUEfAABAQNfAAMDNEsABAQGXwkHAgYGNUsKAQgIBl8JBwIGBjUGTD8/Cws/ST9ICz4LPTg2NDMxLyspJCIWFBILCBUrEzY3MxYXByYnBgcSJjU0NjY3NzU0IyIGFRQXFhYXFhYVFAYjIiY1NDY2MzIWFRUUMzI2NTMUBiMiJicnBgYjNjY3NQcGBhUUFjNhSyQoJEsJRTU2RBFNNEUxXF0iOAMCCQQSExkTFiQpQSJCYB8ZFhIjLSsrAgUPQy09MxRXMCsmGAIJMWZmMQ0kODkj/fg0QjM6GQkRVV0jFgoFAwYBBRIQFRIiICU2G0VJ9jI6KjxSMy0CIz8kRzdfEwo7Ni4hAAQALv/0AdwChAALABcASwBWAHhAdU9OHwMIBUcBBwgCSgAFBAgEBQh+AAgHBAgHfAIBAA0DDAMBBgABZwAEBAZfAAYGNEsABwcJXw4KAgkJNUsPAQsLCV8OCgIJCTUJTExMGBgMDAAATFZMVRhLGEpFQ0FAPjw4NjEvIyEMFwwWEhAACwAKJBAIFSsSJjU0NjMyFhUUBiMyJjU0NjMyFhUUBiMCJjU0NjY3NzU0IyIGFRQXFhYXFhYVFAYjIiY1NDY2MzIWFRUUMzI2NTMUBiMiJicnBgYjNjY3NQcGBhUUFjNzHR0TFBwcFKkdHRMUHBwUx000RTFcXSI4AwIJBBITGRMWJClBIkJgHxkWEiMtKysCBQ9DLT0zFFcwKyYYAiQdExQcHBQTHR0TFBwcFBMd/dA0QjM6GQkRVV0jFgoFAwYBBRIQFRIiICU2G0VJ9jI6KjxSMy0CIz8kRzdfEwo7Ni4hAAADAC7/9AHcAqwACgA+AEkAp0ARCgkCAwBCQRIDBQI6AQQFA0pLsCNQWEA4AAIBBQECBX4ABQQBBQR8AAAAK0sAAQEDXwADAzRLAAQEBl8JBwIGBjVLCgEICAZfCQcCBgY1BkwbQDgAAAMAgwACAQUBAgV+AAUEAQUEfAABAQNfAAMDNEsABAQGXwkHAgYGNUsKAQgIBl8JBwIGBjUGTFlAFj8/Cws/ST9ICz4LPSISJCUsLiQLCBsrEyY1NDYzMhYXFwcCJjU0NjY3NzU0IyIGFRQXFhYXFhYVFAYjIiY1NDY2MzIWFRUUMzI2NTMUBiMiJicnBgYjNjY3NQcGBhUUFjNwHA8NDhYNXA11TTRFMVxdIjgDAgkEEhMZExYkKUEiQmAfGRYSIy0rKwIFD0MtPTMUVzArJhgCYRUXDhEOEoUL/fg0QjM6GQkRVV0jFgoFAwYBBRIQFRIiICU2G0VJ9jI6KjxSMy0CIz8kRzdfEwo7Ni4hAAQALv/0AdwCuAALABcASwBWAIBAfU9OHwMIBUcBBwgCSgAFBAgEBQh+AAgHBAgHfA0BAwwBAQYDAWcAAgIAXwAAACtLAAQEBl8ABgY0SwAHBwlfDgoCCQk1Sw8BCwsJXw4KAgkJNQlMTEwYGAwMAABMVkxVGEsYSkVDQUA+PDg2MS8jIQwXDBYSEAALAAokEAgVKxImNTQ2MzIWFRQGIzY2NTQmIyIGFRQWMwImNTQ2Njc3NTQjIgYVFBcWFhcWFhUUBiMiJjU0NjYzMhYVFRQzMjY1MxQGIyImJycGBiM2Njc1BwYGFRQWM7w6OigpOTkpHysrHx8rKx9pTTRFMVxdIjgDAgkEEhMZExYkKUEiQmAfGRYSIy0rKwIFD0MtPTMUVzArJhgB9DooKTk5KSg6GCsfHysrHx8r/eg0QjM6GQkRVV0jFgoFAwYBBRIQFRIiICU2G0VJ9jI6KjxSMy0CIz8kRzdfEwo7Ni4hAAMALv/0AdwCjAAXAEsAVgB1QHIXAQYCT04fAwgFRwEHCANKDAsCAEgABQQIBAUIfgAIBwQIB3wAAAADAgADZwABAAIGAQJnAAQEBl8ABgY0SwAHBwlfDAoCCQk1Sw0BCwsJXwwKAgkJNQlMTEwYGExWTFUYSxhKRUMSJCUsKyQkJCIOCB0rEzY2MzIWFxYWMzI3FwYGIyImJyYmIyIHEiY1NDY2Nzc1NCMiBhUUFxYWFxYWFRQGIyImNTQ2NjMyFhUVFDMyNjUzFAYjIiYnJwYGIzY2NzUHBgYVFBYzVgYsJBMiFhMaDyIMEQYsJBMiFhMaDyIMFE00RTFcXSI4AwIJBBITGRMWJClBIkJgHxkWEiMtKysCBQ9DLT0zFFcwKyYYAi4kNAsJCAgqBCQ0CwkICCr9yjRCMzoZCRFVXSMWCgUDBgEFEhAVEiIgJTYbRUn2MjoqPFIzLQIjPyRHN18TCjs2LiEAAAMALv/0ApQB1AA9AEQAUAB0QHEiAQEABwEKAUkBBApHOQILBgRKAAEACgABCn4ABgQLBAYLfg0BCgAEBgoEZQkBAAACXwMBAgI0Sw4BCwsHXwwIAgcHNUsABQUHXwwIAgcHNQdMRUU+PgAARVBFTz5EPkRCQAA9ADwiEiIlIyUsKQ8IHCsWJjU0NjY3NzU0IyIGFRQXFhYXFhYVFAYjIiY1NDY2MzIWFzYzMhYWFRQGIyMUFjMyNjczBgYjIiYnIwYGIwE0JiMiBhUGNjcmNQcGBhUUFjN7TTRFMVxdIjgDAgkEEhMZExYkKUEiK0oWMks9TiMOEfU2QC5RCxgGWUdCUxYEEFEuAYoqMDIyjj4OBlcwKyYYDDRCMzoZCRFVXSMWCgUDBgEFEhAVEiIgJTYbHR88QmU1CwdldUZKSV87LSVDAQpQbm9P5jcjLFQQCTw2LiEAAAIAFv/0AdACyAAZACgAdbYNAgIGBQFKS7AqUFhAJgABAQJdAAICKUsABQUDXwADAzRLAAAAKksIAQYGBF8HAQQENQRMG0AkAAIAAQMCAWcABQUDXwADAzRLAAAALUsIAQYGBF8HAQQENQRMWUAVGhoAABooGicgHgAZABgkESMUCQgYKxYmJyMHIxE0JiMjNTMRFzY2MzIWFhUUBgYjNjY1NCYjIgYGFRUUFhYz+EQUBCoSCgw0kgQPPicvUTAwUS8mMjIxHjIdHTIeDDYsVgKaDAoY/rYBJDM/bkNDbj8cbmZmbixNLVwtTSwAAQAw//QBkgHUACgANkAzAAECBAIBBH4ABAMCBAN8AAICAF8AAAA0SwADAwVfBgEFBTUFTAAAACgAJxIkKiUmBwgZKxYmJjU0NjYzMhYWFRQGIyImNTQ2NzY1NCYmIyIGFRQWMzI2NzMOAiO6WTEyWTkuRCQgFxQbFA4QFSwhPy0sQD1CBxgDJEYxDEBuQkJuQCc9Hx8jGhISGAQFDQweF2xsbGxWOilNMgABADD/LAGSAdQAQQCktRABCAYBSkuwG1BYQD8ABAUHBQQHfgAHBgUHBnwAAAIBAgABfgAJAAIACQJnAAUFA18AAwM0SwAGBghfAAgINUsAAQEKXwsBCgouCkwbQDwABAUHBQQHfgAHBgUHBnwAAAIBAgABfgAJAAIACQJnAAELAQoBCmMABQUDXwADAzRLAAYGCF8ACAg1CExZQBQAAABBAEA8OhMSJColKCMiJAwIHSsWJjU0NjMyFxYzMjY1NCMjNy4CNTQ2NjMyFhYVFAYjIiY1NDY3NjU0JiYjIgYVFBYzMjY3Mw4CIwczMhYVFAYj0zMOChcEByEbHjopDjVPKzJZOS5EJCAXFBsUDhAVLCE/LSxAPUIHGAMkRTAGGiEvMDbUIR4LECAoGRcwVwZCaT5CbkAnPR8fIxoSEhgEBQ0MHhdsbGxsVjooTjImJSMlNQAAAgAw//QB6gLIAB4ALQCAthoKAgMGAUpLsCpQWEArAAEBAl0AAgIpSwAGBgBfAAAANEsAAwMEXQAEBCpLCQEHBwVfCAEFBTUFTBtAKQACAAEAAgFlAAYGAF8AAAA0SwADAwRdAAQELUsJAQcHBV8IAQUFNQVMWUAWHx8AAB8tHywoJgAeAB0RIxEmJgoIGSsWJiY1NDY2MzIWFzcRNCYjIzUzERQWMzMVIzUnBgYjPgI1NTQmJiMiBhUUFjOxUTAwUS8nPg8ECgxIpgoMNJIEEzsmKTIdHTIeMTIyMQw/bkNDbj8zJAEBHAwKGP1mDAoYSgEoLxwsTS1cLU0sbmZmbgAAAgAw//QBwALIAB8AKwBsQBEXFhUUDw4NDAgAAQkBAwACSkuwKlBYQBwAAQEpSwADAwBfAAAANEsGAQQEAl8FAQICNQJMG0AcAAEAAYMAAwMAXwAAADRLBgEEBAJfBQECAjUCTFlAEyAgAAAgKyAqJiQAHwAeGSYHCBYrFiYmNTQ2NjMyFzcmJwcnNyYnMxYXNxcHFhcWFRQGBiM2NjU0JiMiBhUUFjPBXDU1XDcgHwMXPWwPaC06YBopbA9pIyBcNls3PDQ0PDw0NDwMQW5BQW5BDAQrTUMXQTk2FzNEF0IrMY98VXo/GHFnZ3FxZ2dxAAACADD/9AGkAdQAGAAfAD9APAADAQIBAwJ+CAEGAAEDBgFlAAUFAF8AAAA0SwACAgRfBwEEBDUETBkZAAAZHxkfHRsAGAAXEiIlJQkIGCsWJjU0NjYzMhYWFRQGIyMUFjMyNjczBgYjEzQmIyIGFaFxMlk3PU4jDhH5OUEuUQsYBllHTCowMzUMfnBAb0NCZTULB2R2RkpJXwEKUG5vTwAAAwAw//QBpAKsAAoAIwAqAIO1CgEBAAFKS7AjUFhALAAEAgMCBAN+CQEHAAIEBwJlAAAAK0sABgYBXwABATRLAAMDBV8IAQUFNQVMG0AsAAABAIMABAIDAgQDfgkBBwACBAcCZQAGBgFfAAEBNEsAAwMFXwgBBQU1BUxZQBYkJAsLJCokKigmCyMLIhIiJSsjCggZKxM3NjYzMhYVFAcHAiY1NDY2MzIWFhUUBiMjFBYzMjY3MwYGIxM0JiMiBhXXXA0WDg0PHIBDcTJZNz1OIw4R+TlBLlELGAZZR0wqMDM1AgeFEg4RDhcVZf34fnBAb0NCZTULB2R2RkpJXwEKUG5vTwADADD/9AGkAqAACgAjACoATkBLCggGBQQBAAFKAAABAIMABAIDAgQDfgkBBwACBAcCZQAGBgFfAAEBNEsAAwMFXwgBBQU1BUwkJAsLJCokKigmCyMLIhIiJS0SCggZKxM2NzMWFwcmJwYHEiY1NDY2MzIWFhUUBiMjFBYzMjY3MwYGIxM0JiMiBhVtSyQoJEsJRTU2RCtxMlk3PU4jDhH5OUEuUQsYBllHTCowMzUCCTFmZjENJDg5I/34fnBAb0NCZTULB2R2RkpJXwEKUG5vTwAEADD/9AGkAoQACwAXADAANwBeQFsABwUGBQcGfgIBAAwDCwMBBAABZw4BCgAFBwoFZQAJCQRfAAQENEsABgYIXw0BCAg1CEwxMRgYDAwAADE3MTc1MxgwGC8tLCooJiQfHQwXDBYSEAALAAokDwgVKxImNTQ2MzIWFRQGIzImNTQ2MzIWFRQGIwImNTQ2NjMyFhYVFAYjIxQWMzI2NzMGBiMTNCYjIgYVfx0dExQcHBSpHR0TFBwcFK1xMlk3PU4jDhH5OUEuUQsYBllHTCowMzUCJB0TFBwcFBMdHRMUHBwUEx390H5wQG9DQmU1CwdkdkZKSV8BClBub08AAAMAMP/0AaQCrAAKACMAKgCEtgoJAgEAAUpLsCNQWEAsAAQCAwIEA34JAQcAAgQHAmUAAAArSwAGBgFfAAEBNEsAAwMFXwgBBQU1BUwbQCwAAAEAgwAEAgMCBAN+CQEHAAIEBwJlAAYGAV8AAQE0SwADAwVfCAEFBTUFTFlAFiQkCwskKiQqKCYLIwsiEiIlKiQKCBkrEyY1NDYzMhYXFwcCJjU0NjYzMhYWFRQGIyMUFjMyNjczBgYjEzQmIyIGFXwcDw0OFg1cDVtxMlk3PU4jDhH5OUEuUQsYBllHTCowMzUCYRUXDhEOEoUL/fh+cEBvQ0JlNQsHZHZGSklfAQpQbm9PAAABABwAAAFmAtAALACgS7AJUFhAKQAEBQIFBHAABQUDXwADAylLBwEBAQJdBgECAixLCAEAAAldAAkJKglMG0uwKlBYQCoABAUCBQQCfgAFBQNfAAMDKUsHAQEBAl0GAQICLEsIAQAACV0ACQkqCUwbQCgABAUCBQQCfgADAAUEAwVnBwEBAQJdBgECAixLCAEAAAldAAkJLQlMWVlADiwrIxETKSQkERMgCggdKzczMjY1ESM1MzU0NjYzMhYVFAYjIiY1NDY3NjU0JiMiBhUVMxUjERQWMzMVIxw0DApKSi1GJis8GRYSFwoIEB8UIS5eXgoMSPAYCgwBfhxFQ1goNTEaHhcTChQGCQ8RD0BPYRz+ggwKGAAAAwA0/xICEAHUAEUAUQBeAKtADy4XAgIDCwEECQUBCgUDSkuwDFBYQDIAAgMJAwJwDQEJAAQFCQRnBgEFAAoLBQplCAEDAwBfAQEAADRLDgELCwdfDAEHBzYHTBtAMwACAwkDAgl+DQEJAAQFCQRnBgEFAAoLBQplCAEDAwBfAQEAADRLDgELCwdfDAEHBzYHTFlAJ1JSRkYAAFJeUl1ZVkZRRlBMSgBFAERAPTs5NTMsKiEfGxkUEg8IFCsWJjU0Njc1JjU0Njc1JiY1NDY2MzIWFhc2NjMyFhUUBiMiJjU0NzY2NTQmIyIGBxYVFAYGIyIGFRQWMzI3NjMzMhYVFAYjEjY1NCYjIgYVFBYzEjY1NCYjIyIGFRQWM7SAOihYPy4qOzJRLx05KQYJKBQiLBcTEBgRBgUQCxIdAhwwUTE5WSIeFQ0ME2dAVndhGjQ0Li40NC5cbCUub0BeakLuODwlOAYDEzcpLwgDEkk8M0onExkIGhooIBgeERMWCgQHBwgIHRMnNTJLJx8kEw4BAUVDRkoBkkpCQkpKQkJK/oYzPR8tKzMvLwAAAQAcAAACAALIAC4AZ7UMAQAHAUpLsCpQWEAjAAEBAl0AAgIpSwAHBwNfAAMDNEsIBgQDAAAFXQkBBQUqBUwbQCEAAgABAwIBZwAHBwNfAAMDNEsIBgQDAAAFXQkBBQUtBUxZQA4uLSYlIRElJBElIAoIHSs3MzI2NRE0JiMjNTMRFzY2MzIWFREUFjMzFSM1MzI2NRE0JiMiBgYVFRQWMzMVIxw4DAoKDDiWBBdEKUk9CgwqyCoMCiMqIzcfCgwq1hgKDAJsDAoY/q4BMC9aP/7zDAoYGAoMASAsPjFVNNAMChgAAgAmAAAA7gKsAAsAHgCKS7AjUFhAIQcBAQEAXwAAACtLAAMDBF0ABAQsSwUBAgIGXQAGBioGTBtLsCpQWEAfAAAHAQEEAAFnAAMDBF0ABAQsSwUBAgIGXQAGBioGTBtAHwAABwEBBAABZwADAwRdAAQELEsFAQICBl0ABgYtBkxZWUAUAAAeHRwaFxYVEw4MAAsACiQICBUrEiY1NDYzMhYVFAYjAzMyNjURNCYjIzUzERQWMzMVI24eHhYXHR0XXioMCgoMKogKDCrIAkQeFhcdHRcWHv3UCgwBbAwKGP5mDAoYAAABACYAAADuAcgAEgBBS7AqUFhAFgABAQJdAAICLEsDAQAABF0ABAQqBEwbQBYAAQECXQACAixLAwEAAARdAAQELQRMWbcRIxElIAUIGSs3MzI2NRE0JiMjNTMRFBYzMxUjJioMCgoMKogKDCrIGAoMAWwMChj+ZgwKGAAAAgAmAAABFAKsAAoAHQB4tQoBAwABSkuwI1BYQBsAAAArSwACAgNdAAMDLEsEAQEBBV0ABQUqBUwbS7AqUFhAGwAAAwCDAAICA10AAwMsSwQBAQEFXQAFBSoFTBtAGwAAAwCDAAICA10AAwMsSwQBAQEFXQAFBS0FTFlZQAkRIxElJiMGCBorEzc2NjMyFhUUBwcDMzI2NRE0JiMjNTMRFBYzMxUja1wNFg4NDxyAUioMCgoMKogKDCrIAgeFEg4RDhcVZf4cCgwBbAwKGP5mDAoYAAACAAcAAAENAqAACgAdAFhACQoIBgUEAwABSkuwKlBYQBsAAAMAgwACAgNdAAMDLEsEAQEBBV0ABQUqBUwbQBsAAAMAgwACAgNdAAMDLEsEAQEBBV0ABQUtBUxZQAkRIxElKBIGCBorEzY3MxYXByYnBgcTMzI2NRE0JiMjNTMRFBYzMxUjB0skKCRLCUU1NkQcKgwKCgwqiAoMKsgCCTFmZjENJDg5I/4cCgwBbAwKGP5mDAoYAAMACwAAARMChAALABcAKgBuS7AqUFhAIgIBAAoDCQMBBgABZwAFBQZdAAYGLEsHAQQECF0ACAgqCEwbQCICAQAKAwkDAQYAAWcABQUGXQAGBixLBwEEBAhdAAgILQhMWUAcDAwAACopKCYjIiEfGhgMFwwWEhAACwAKJAsIFSsSJjU0NjMyFhUUBiMyJjU0NjMyFhUUBiMDMzI2NRE0JiMjNTMRFBYzMxUjKB0dExQcHBSVHR0TFBwcFLEqDAoKDCqICgwqyAIkHRMUHBwUEx0dExQcHBQTHf30CgwBbAwKGP5mDAoYAAAC//QAAADuAqwACgAdAHm2CgkCAwABSkuwI1BYQBsAAAArSwACAgNdAAMDLEsEAQEBBV0ABQUqBUwbS7AqUFhAGwAAAwCDAAICA10AAwMsSwQBAQEFXQAFBSoFTBtAGwAAAwCDAAICA10AAwMsSwQBAQEFXQAFBS0FTFlZQAkRIxElJSQGCBorEyY1NDYzMhYXFwcDMzI2NRE0JiMjNTMRFBYzMxUjEBwPDQ4WDVwNaioMCgoMKogKDCrIAmEVFw4RDhKFC/4cCgwBbAwKGP5mDAoYAAL/2v8SAOQCrAALACsAp0uwCVBYQCgAAgQDAwJwBwEBAQBfAAAAK0sABAQFXQAFBSxLAAMDBmAIAQYGNgZMG0uwI1BYQCkAAgQDBAIDfgcBAQEAXwAAACtLAAQEBV0ABQUsSwADAwZgCAEGBjYGTBtAJwACBAMEAgN+AAAHAQEFAAFnAAQEBV0ABQUsSwADAwZgCAEGBjYGTFlZQBgMDAAADCsMKiYlJCIdGxIQAAsACiQJCBUrEiY1NDYzMhYVFAYjAiY1NDYzMhYVFAYHBhUUFjMyNjURNCYjIzUzERQGBiOaHh4WFx0dF5k9HxYRFAsKDx8UIS4KDEimLUYmAkQeFhcdHRcWHvzOMysbJRMPDBEJDhARD0BPAeEMChj+DUNYKAABABwAAAHqAsgANABvQAktLBwMBAADAUpLsCpQWEAkAAEBAl0AAgIpSwUBAwMEXQAEBCxLCQgGAwAAB10KAQcHKgdMG0AiAAIAAQQCAWcFAQMDBF0ABAQsSwkIBgMAAAddCgEHBy0HTFlAEDQzMjAhESYhEScRJSALCB0rNzMyNjURNCYjIzUzETc2NjU0JiMjNTMVIyIGBwcXFhYzMxUjNTMyNjU0JicnBxUUFjMzFSMcNAwKCgw0kogLBxMPGswgGyobTJwMEhAU1BoNDgYHYi4KDCDIGAoMAmwMChj+A6YMDgsNDRgYHCFd3hEPGBgJCwsOC4w4dgwKGAABABwAAAD4AsgAEgA/S7AqUFhAFgABAQJdAAICKUsDAQAABF0ABAQqBEwbQBQAAgABAAIBZwMBAAAEXQAEBC0ETFm3ESMRJSAFCBkrNzMyNjURNCYjIzUzERQWMzMVIxw0DAoKDDSSCgw03BgKDAJsDAoY/WYMChgAAAIAHAAAAXgCyAASAB4AWUuwKlBYQB8ABQcBBgAFBmcAAQECXQACAilLAwEAAARdAAQEKgRMG0AdAAIAAQUCAWcABQcBBgAFBmcDAQAABF0ABAQtBExZQA8TExMeEx0lESMRJSAICBorNzMyNjURNCYjIzUzERQWMzMVIwAmNTQ2MzIWFRQGIxw0DAoKDDSSCgw03AESHh4WFx0dFxgKDAJsDAoY/WYMChgBQB4WFx0dFxYeAAEAJgAAAvoB1ABJAH62EwwCAAEBSkuwKlBYQCgMAQgIA18EAQMDNEsAAQECXQACAixLDQsJBwUFAAAGXQ4KAgYGKgZMG0AoDAEICANfBAEDAzRLAAEBAl0AAgIsSw0LCQcFBQAABl0OCgIGBi0GTFlAGElIR0U/PTg2NTQzMSUhESUlJBElIA8IHSs3MzI2NRE0JiMjNTMVFzY2MzIWFzM2NjMyFhURFBYzMxUjNTMyNjURNCYjIgYGFRUUFjMzFSM1MzI2NRE0JiMiBgYVFRQWMzMVIyYqDAoKDCqIBBVDJjs5CgQMRy9JPQoMKsgqDAomJB41IQoMKsgqDAomJB41IQoMKsgYCgwBbAwKGFABLi9ALChEYkL+/gwKGBgKDAElKD0vUjPWDAoYGAoMASUoPS9SM9YMChgAAQAmAAAB/AHUAC4AabUMAQABAUpLsCpQWEAjAAcHA18AAwM0SwABAQJdAAICLEsIBgQDAAAFXQkBBQUqBUwbQCMABwcDXwADAzRLAAEBAl0AAgIsSwgGBAMAAAVdCQEFBS0FTFlADi4tJiUhESUkESUgCggdKzczMjY1ETQmIyM1MxUXNjYzMhYVERQWMzMVIzUzMjY1ETQmIyIGBhUVFBYzMxUjJioMCgoMKogEF0QpST0KDCrIKgwKIyojNx8KDCrIGAoMAWwMChhSATAvWj/+8wwKGBgKDAEgLD4xVTTQDAoYAAACACYAAAH8AowAFwBGAJtADxcBBwIkAQQFAkoMCwIASEuwKlBYQDMAAAADAgADZwABAAIHAQJnAAsLB18ABwc0SwAFBQZdAAYGLEsMCggDBAQJXQ0BCQkqCUwbQDMAAAADAgADZwABAAIHAQJnAAsLB18ABwc0SwAFBQZdAAYGLEsMCggDBAQJXQ0BCQktCUxZQBZGRURCPDo1MzIxJSQRJSIkJCQiDggdKxM2NjMyFhcWFjMyNxcGBiMiJicmJiMiBwMzMjY1ETQmIyM1MxUXNjYzMhYVERQWMzMVIzUzMjY1ETQmIyIGBhUVFBYzMxUjhgYsJBMiFhMaDyIMEQYsJBMiFhMaDyIMcSoMCgoMKogEF0QpST0KDCrIKgwKIyojNx8KDCrIAi4kNAsJCAgqBCQ0CwkICCr97goMAWwMChhSATAvWj/+8wwKGBgKDAEgLD4xVTTQDAoYAAACADD/9AHAAdQADwAbACxAKQACAgBfAAAANEsFAQMDAV8EAQEBNQFMEBAAABAbEBoWFAAPAA4mBggVKxYmJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjPBXDU1XDc3XDU1XDc8NDQ8PDQ0PAxBbkFBbkFBbkFBbkEYcWdncXFnZ3EAAwAw//QBwAKsAAoAGgAmAGC1CgEBAAFKS7AjUFhAHAAAACtLAAMDAV8AAQE0SwYBBAQCXwUBAgI1AkwbQBwAAAEAgwADAwFfAAEBNEsGAQQEAl8FAQICNQJMWUATGxsLCxsmGyUhHwsaCxksIwcIFisTNzY2MzIWFRQHBwImJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjPfXA0WDg0PHIArXDU1XDc3XDU1XDc8NDQ8PDQ0PAIHhRIOEQ4XFWX9+EFuQUFuQUFuQUFuQRhxZ2dxcWdncQAAAwAw//QBwAKgAAoAGgAmADtAOAoIBgUEAQABSgAAAQCDAAMDAV8AAQE0SwYBBAQCXwUBAgI1AkwbGwsLGyYbJSEfCxoLGS4SBwgWKxM2NzMWFwcmJwYHEiYmNTQ2NjMyFhYVFAYGIzY2NTQmIyIGFRQWM3VLJCgkSwlFNTZEQ1w1NVw3N1w1NVw3PDQ0PDw0NDwCCTFmZjENJDg5I/34QW5BQW5BQW5BQW5BGHFnZ3FxZ2dxAAAEADD/9AHAAoQACwAXACcAMwBIQEUCAQAJAwgDAQQAAWcABgYEXwAEBDRLCwEHBwVfCgEFBTUFTCgoGBgMDAAAKDMoMi4sGCcYJiAeDBcMFhIQAAsACiQMCBUrEiY1NDYzMhYVFAYjMiY1NDYzMhYVFAYjAiYmNTQ2NjMyFhYVFAYGIzY2NTQmIyIGFRQWM4cdHRMUHBwUqR0dExQcHBSVXDU1XDc3XDU1XDc8NDQ8PDQ0PAIkHRMUHBwUEx0dExQcHBQTHf3QQW5BQW5BQW5BQW5BGHFnZ3FxZ2dxAAADADD/9AHAAqwACgAaACYAYbYKCQIBAAFKS7AjUFhAHAAAACtLAAMDAV8AAQE0SwYBBAQCXwUBAgI1AkwbQBwAAAEAgwADAwFfAAEBNEsGAQQEAl8FAQICNQJMWUATGxsLCxsmGyUhHwsaCxkrJAcIFisTJjU0NjMyFhcXBwImJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjOEHA8NDhYNXA1DXDU1XDc3XDU1XDc8NDQ8PDQ0PAJhFRcOEQ4ShQv9+EFuQUFuQUFuQUFuQRhxZ2dxcWdncQADADD/9AHAAdQAGQAhACkAPUA6DQECACcmIRgOCwEHAwICSgwBAEgZAQFHAAICAF8AAAA0SwQBAwMBXwABATUBTCIiIikiKCUrJwUIFys3NyYmNTQ2NjMyFhc3FwcWFhUUBgYjIiYnBwEmIyIGFRQXFjY1NCcHFjMwMxgbNVw3JUMbLxYzGBs1XDclQxsvAREbRDw0CaM0CcYbRAY+IFMtQW5BHhw6Ej4gUy1BbkEeHDoBek5xZzstcHFnOy3yTgADADD/9AHAAowAFwAnADMAS0BIFwEEAgFKDAsCAEgAAAADAgADZwABAAIEAQJnAAYGBF8ABAQ0SwkBBwcFXwgBBQU1BUwoKBgYKDMoMi4sGCcYJigkJCQiCggZKxM2NjMyFhcWFjMyNxcGBiMiJicmJiMiBxImJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjNqBiwkEyIWExoPIgwRBiwkEyIWExoPIgxGXDU1XDc3XDU1XDc8NDQ8PDQ0PAIuJDQLCQgIKgQkNAsJCAgq/cpBbkFBbkFBbkFBbkEYcWdncXFnZ3EAAAMAMP/0AtYB1AAmADIAOQBYQFUKAQoHIgEDBAJKAAQCAwIEA34NAQoAAgQKAmUJAQcHAF8BAQAANEsMCAIDAwVfCwYCBQU1BUwzMycnAAAzOTM5NzUnMicxLSsAJgAlIhIiJSUmDggaKxYmJjU0NjYzMhYXMzY2MzIWFhUUBiMjFBYzMjY3MwYGIyInIwYGIzY2NTQmIyIGFRQWMyU0JiMiBhW6WTExWTovTxoEGkwuPU4jDhH5OUEuUQsYBllHajYEHU4tOjQ0OjoyMjoBiCowMzUMQG5CQm5ALicoLUJlNQsHZHZGSklfTyQrGINVVYOCVlaC8lBub08AAAIAHP8aAdYB1AAjADIARkBDGwwCCAEBSgAHBwNfAAMDNEsAAQECXQACAixLCQEICARfAAQENUsFAQAABl0ABgYuBkwkJCQyJDElESYmJBElIAoIHCsXMzI2NRE0JiMjNTMVFzY2MzIWFhUUBgYjIiYnBxEUFjMzFSMkNjU0JiMiBgYVFRQWFjMcNAwKCgw0kgQTOyYvUTAwUS8nPg8ECgw03AEwMjIxHjIdHTIezgoMAlIMChhKASgvP25DQ24/MyQB/v4MChj2bmZmbixNLVwtTSwAAgAa/wQBxAKsABwAKABVQBILAQABCgECAAJKKBwbGg4FA0dLsCNQWEAYAAABAgEAAn4AAQErSwADAwJfAAICNANMG0AVAAEAAYMAAAIAgwADAwJfAAICNANMWbYvJBUWBAgYKxc3NjY1ETQjIgcHJzczERc2NjMyFhUUBgcGBxUHEjc2NjU0IyIGBhUVGjQLCRAHCR4KdBwGHFgsLkZYRjhEhromMTc+HT4p5BYFDAsDEhIECxgx/rQCNz86PUSQOy8fxzUBMSMugkZaOloszQAAAgAw/xoB6gHUAB4ALQBAQD0UBQIHBgFKAAMDLEsABgYCXwACAjRLCAEHBwFfAAEBNUsEAQAABV0ABQUuBUwfHx8tHywoESMUJiYgCQgbKwUzMjY1EScGBiMiJiY1NDY2MzIWFzM3MxEUFjMzFSMmNjY1NTQmJiMiBhUUFjMBDjQMCgQPPicvUTAwUS8oRBQEKhIKDDTcBTIdHTIeMTIyMc4KDAECASQzP25DQ24/NixW/YAMChj2LE0tXC1NLG5mZm4AAAEAJgAAAYYB1AAsAKC1DAEEAQFKS7AJUFhAJwAEAQAFBHAABQUDXwADAzRLAAEBAl0AAgIsSwYBAAAHXQAHByoHTBtLsCpQWEAoAAQBAAEEAH4ABQUDXwADAzRLAAEBAl0AAgIsSwYBAAAHXQAHByoHTBtAKAAEAQABBAB+AAUFA18AAwM0SwABAQJdAAICLEsGAQAAB10ABwctB0xZWUALESYpJCQRJSAICBwrNzMyNjURNCYjIzUzFRc2NjMyFhUUBiMiJjU0NzY2NTQmIyIGBhUVFBYzMxUjJioMCgoMKogEFUMmJjAfGBMaFAkJEQ8fOSIKDCrIGAoMAWwMChhkATQ9LCYWKhQSFQ8GCggJCzxgNLoMChgAAAEANP/0AYgB1AA3AExASQADBgUGAwV+AAgAAQAIAX4ABgYCXwACAjRLAAUFBF0ABAQsSwAAAAdfCQEHBzVLAAEBB18JAQcHNQdMNzYkKyMREiMrIhAKCB0rNzMXFjMyNjU0JicnJiY1NDYzMhYXFjMyNzczFSMnJiYjIgYVFBYXFxYWFRQGIyImJyYmIyIHByM8EiU2Vi4tIx1yNj5MOh0zERYLDQMCEhIOF0slJTAvKWwwMEw+JS4WCRIHGAkEErpPXy0nFyULLhY+MD0+Ew0QEhSYIzkuJSEdJREtFDkzQz8UEQcKIhQAAAEAHP/0Ad4CzgA9AMC1NQECAwFKS7AJUFhAMQAAAgYBAHAABAQHXwAHBylLAAICA18AAwMsSwAGBgVdAAUFKksAAQEIYAkBCAg1CEwbS7AqUFhAMgAAAgYCAAZ+AAQEB18ABwcpSwACAgNfAAMDLEsABgYFXQAFBSpLAAEBCGAJAQgINQhMG0AuAAACBgIABn4ABwAEAwcEZwADAAIAAwJnAAYGBV0ABQUtSwABAQhgCQEICDUITFlZQBEAAAA9ADwmIRQjISQpJAoIHCsEJjU0NjMyFhUUBgcGFRQWMzI2NTQmIyM1MzI2NTQjIgYGFREjNTMyNjURNDY2MzIWFRQGBgcVFhYVFAYGIwEKQB4WGBQQDgwhGCUoRD4mJjY0UxwxIJI0DAo3VS5GVC1CIEhrLEwuDDYqHR8YEg4RBwcJERNKXGmFHFE3ciRLN/3wGAoMAc9FXi5KOylAKAgEFXtqOVcuAAABABz/9AE8AogAGQA4QDUAAgECgwAGAAUABgV+BAEAAAFfAwEBASxLAAUFB18IAQcHNQdMAAAAGQAYESMRERMhEwkIGysWJjURIzUzMjY1NTMVMxUjERQWMzI1MxQGI6E7ShYtMxx8fBgdRxInRwxANwFBHGE7JMAc/roeKHhDYQAAAQAg//QB9gHIACQAabUgAQUAAUpLsCpQWEAiAwEAAAFdBAEBASxLAAUFBl0ABgYqSwACAgdfCAEHBzUHTBtAIgMBAAABXQQBAQEsSwAFBQZdAAYGLUsAAgIHXwgBBwc1B0xZQBAAAAAkACMRIxEmIxElCQgbKxYmNRE0JiMjNTMRFBYzMjY2NTU0JiMjNTMRFBYzMxUjNScGBiOdPQoMKogjKiM3HwoMKogKDCqIBBdEKQxaPwENDAoY/rIsPjFVNNAMChj+ZgwKGFIBMC8AAAIAIP/0AfYCrAAKAC8AqUAKCgECACsBBgECSkuwI1BYQCcAAAArSwQBAQECXQUBAgIsSwAGBgddAAcHKksAAwMIXwkBCAg1CEwbS7AqUFhAJwAAAgCDBAEBAQJdBQECAixLAAYGB10ABwcqSwADAwhfCQEICDUITBtAJwAAAgCDBAEBAQJdBQECAixLAAYGB10ABwctSwADAwhfCQEICDUITFlZQBELCwsvCy4RIxEmIxErIwoIHCsTNzY2MzIWFRQHBwImNRE0JiMjNTMRFBYzMjY2NTU0JiMjNTMRFBYzMxUjNScGBiPtXA0WDg0PHIBdPQoMKogjKiM3HwoMKogKDCqIBBdEKQIHhRIOEQ4XFWX9+Fo/AQ0MChj+siw+MVU00AwKGP5mDAoYUgEwLwACACD/9AH2AqAACgAvAHxADQoIBgUEAgArAQYBAkpLsCpQWEAnAAACAIMEAQEBAl0FAQICLEsABgYHXQAHBypLAAMDCF8JAQgINQhMG0AnAAACAIMEAQEBAl0FAQICLEsABgYHXQAHBy1LAAMDCF8JAQgINQhMWUARCwsLLwsuESMRJiMRLRIKCBwrEzY3MxYXByYnBgcSJjURNCYjIzUzERQWMzI2NjU1NCYjIzUzERQWMzMVIzUnBgYjg0skKCRLCUU1NkQRPQoMKogjKiM3HwoMKogKDCqIBBdEKQIJMWZmMQ0kODkj/fhaPwENDAoY/rIsPjFVNNAMChj+ZgwKGFIBMC8AAwAg//QB9gKEAAsAFwA8AJe1OAEJBAFKS7AqUFhALgIBAA0DDAMBBQABZwcBBAQFXQgBBQUsSwAJCQpdAAoKKksABgYLXw4BCws1C0wbQC4CAQANAwwDAQUAAWcHAQQEBV0IAQUFLEsACQkKXQAKCi1LAAYGC18OAQsLNQtMWUAmGBgMDAAAGDwYOzc2NTMwLy4sJiQhIB8dDBcMFhIQAAsACiQPCBUrEiY1NDYzMhYVFAYjMiY1NDYzMhYVFAYjAiY1ETQmIyM1MxEUFjMyNjY1NTQmIyM1MxEUFjMzFSM1JwYGI5UdHRMUHBwUqR0dExQcHBTHPQoMKogjKiM3HwoMKogKDCqIBBdEKQIkHRMUHBwUEx0dExQcHBQTHf3QWj8BDQwKGP6yLD4xVTTQDAoY/mYMChhSATAvAAIAIP/0AfYCrAAKAC8AqkALCgkCAgArAQYBAkpLsCNQWEAnAAAAK0sEAQEBAl0FAQICLEsABgYHXQAHBypLAAMDCF8JAQgINQhMG0uwKlBYQCcAAAIAgwQBAQECXQUBAgIsSwAGBgddAAcHKksAAwMIXwkBCAg1CEwbQCcAAAIAgwQBAQECXQUBAgIsSwAGBgddAAcHLUsAAwMIXwkBCAg1CExZWUARCwsLLwsuESMRJiMRKiQKCBwrEyY1NDYzMhYXFwcCJjURNCYjIzUzERQWMzI2NjU1NCYjIzUzERQWMzMVIzUnBgYjkhwPDQ4WDVwNdT0KDCqIIyojNx8KDCqICgwqiAQXRCkCYRUXDhEOEoUL/fhaPwENDAoY/rIsPjFVNNAMChj+ZgwKGFIBMC8AAAEAEv/0AfoByAAfAEe1DgEGAAFKS7AqUFhAFAUDAgMAAAFdBAEBASxLAAYGKgZMG0AUAAYABoQFAwIDAAABXQQBAQEsAExZQAoTIRErIREiBwgbKxMmJiMjNTMVIyIGFRQXEzc2NjU0JiMjNTMVIyIGBwMjYwoVFR3YHAwUBnBRBAcUEBi2FxYlCoQSAX4aGBgYDQsREP7y7QweCREWGBgdHv5/AAABABL/9ALwAcgANABXtzIhDgMJAAFKS7AqUFhAGAgGBQMCBQAAAV0HBAIBASxLCgEJCSoJTBtAGAoBCQAJhAgGBQMCBQAAAV0HBAIBASwATFlAEDQzMTAhESkhES0hESILCB0rEyYmIyM1MxUjIgYVFBcTNzY2NTQnJiYjIzUzFSMiFRQXEzc2NjU0IyM1MxUjIgYHAyMDAyNnDhcZF9gfDg8GcEQDBA0GDw0e2CgdCF1RBAckGLYXFiUKiBJ4aBIBdSEaGBgQDA0Q/vLZCRQHEhwODhgYHgsV/vftDB4JJxgYHR7+fwFI/rgAAAEAIgAAAeIByAA6AGVACTIiEwUEAAEBSkuwKlBYQB0GBAMDAQECXQUBAgIsSwoJBwMAAAhdCwEICCoITBtAHQYEAwMBAQJdBQECAixLCgkHAwAACF0LAQgILQhMWUASOjk4NiwqESYhESkhESYgDAgdKzczMjY3NycmJiMjNTMVIyIVFBcXNzY1NCYjIzUzFSMiBgcHFxYWMzMVIzUzMjY1NCYnJwcGFRQzMxUjIhoYIBFbeggPERjGGBQGRUIJDwkYrhkVIBBbfwkSFhfQHgsMBANQRA8ZEqYYHRqIwwwKGBgUCwpwYg0TCwwYGBQYhswODBgYCQgFCwWAZRgLHhgAAAEAEv8SAfoByAA4AGq2JRYCAAIBSkuwDFBYQCEAAAIBAQBwBwUEAwICA10GAQMDLEsAAQEIYAkBCAg2CEwbQCIAAAIBAgABfgcFBAMCAgNdBgEDAyxLAAEBCGAJAQgINghMWUARAAAAOAA3IRErIREmJygKCBwrFicmJjU0Njc2MzIWFRQHBhUUMzI2NzcDJiYjIzUzFSMiBhUUFxMTNjY1NCYjIzUzFSMiBgcDBgYjXxkNDwkHDxMXFwgGFB4pChuODBYZIeIgDBQGaFMEBxQQGLYXFiUKoQs+Lu4ZDCESDRcGDx0WDBAKCQ8vIFcBnSAbGBgNCxEQ/s0BEgweCREWGBgdHv4AJT4AAgAS/xIB+gKsAAoAQwCqQAsKAQQAMCECAQMCSkuwDFBYQCYAAQMCAgFwAAAAK0sIBgUDAwMEXQcBBAQsSwACAglgCgEJCTYJTBtLsCNQWEAnAAEDAgMBAn4AAAArSwgGBQMDAwRdBwEEBCxLAAICCWAKAQkJNglMG0AnAAAEAIMAAQMCAwECfggGBQMDAwRdBwEEBCxLAAICCWAKAQkJNglMWVlAEgsLC0MLQiERKyERJicuIwsIHSsTNzY2MzIWFRQHBwInJiY1NDY3NjMyFhUUBwYVFDMyNjc3AyYmIyM1MxUjIgYVFBcTEzY2NTQmIyM1MxUjIgYHAwYGI/tcDRYODQ8cgKkZDQ8JBw8TFxcIBhQeKQobjgwWGSHiIAwUBmhTBAcUEBi2FxYlCqELPi4CB4USDhEOFxVl/RYZDCESDRcGDx0WDBAKCQ8vIFcBnSAbGBgNCxEQ/s0BEgweCREWGBgdHv4AJT4AAAMAEv8SAfoChAALABcAUACZtj0uAgQGAUpLsAxQWEAtAAQGBQUEcAIBAA4DDQMBBwABZwsJCAMGBgddCgEHByxLAAUFDGAPAQwMNgxMG0AuAAQGBQYEBX4CAQAOAw0DAQcAAWcLCQgDBgYHXQoBBwcsSwAFBQxgDwEMDDYMTFlAKBgYDAwAABhQGE9KSEdGRUM4NjU0MzErKSIgDBcMFhIQAAsACiQQCBUrEiY1NDYzMhYVFAYjMiY1NDYzMhYVFAYjACcmJjU0Njc2MzIWFRQHBhUUMzI2NzcDJiYjIzUzFSMiBhUUFxMTNjY1NCYjIzUzFSMiBgcDBgYjox0dExQcHBSpHR0TFBwcFP7tGQ0PCQcPExcXCAYUHikKG44MFhkh4iAMFAZoUwQHFBAYthcWJQqhCz4uAiQdExQcHBQTHR0TFBwcFBMd/O4ZDCESDRcGDx0WDBAKCQ8vIFcBnSAbGBgNCxEQ/s0BEgweCREWGBgdHv4AJT4AAAEAKAAAAYQByAAWAElACRQLCAAEAgABSkuwKlBYQBUAAAABXQABASxLAAICA10AAwMqA0wbQBUAAAABXQABASxLAAICA10AAwMtA0xZthciFiEECBgrNwEjIgcGBhUjNyEVATMyNjc2NjUzByEoAQR6PhoPDxQGAVD+/X8gLAwPDxQG/qoaAZYyHkEHsCD+cBsXHkEHsAAAAQAcAAAB8gLQADsAekuwKlBYQC0ABAUCBQQCfgAFBQNfAAMDKUsKAQEBAl0GAQICLEsLCQcDAAAIXQwBCAgqCEwbQCsABAUCBQQCfgADAAUEAwVnCgEBAQJdBgECAixLCwkHAwAACF0MAQgILQhMWUAUOzo5NzQyLSsRIxQoJCQREyANCB0rNzMyNjURIzUzNTQ2NjMyFhUUBiMiJjU0NzY1NCYjIgYGFRUhERQWMzMVIzUzMjY1ETQmIyMRFBYzMxUjHDQMCkpKPV8yQkQfGBUaDQslHRo6KAEECgwqyCoMCgoMpgoMKtIYCgwBfhwkSmczQCseIRcVFA8LDRUWJE89QP5mDAoYGAoMAWgMCv6CDAoYAAACABwAAAH8AtAAJQA2AIS1JwECCwFKS7AqUFhAKwAEBClLAAsLA18AAwMpSwgBAQECXQ0MAgICLEsJBwUDAAAGXQoBBgYqBkwbQCwABAMLAwQLfgADAAsCAwtnCAEBAQJdDQwCAgIsSwkHBQMAAAZdCgEGBi0GTFlAGCYmJjYmNjIwJSQjIRMhESMRJBETIA4IHSs3MzI2NREjNTM1NDY2MzIXMxEUFjMzFSM1MzI2NREjERQWMzMVIwE1JiY1NDc2NTQmIyIGBhUVHDQMCkpKPV8yGxxHCgw00ioMCrwKDCrSAU4KDBAIHSUaOigYCgwBfhwkSmczCP1mDAoYGAoMAX7+ggwKGAHIZQEXDxMSCA8QGCRPPUAAAwA+AWoBQAK8ADAAOwA/ATRAEwwBAQAFAQIBNAEFAjMsAggFBEpLsAxQWEA7AAUCCAkFcAABAAIFAQJnAAkNAQoJCmIAAAADXwADA1NLCwcCBgYIXwwBCAhUSwsHAgYGBF8ABARUBkwbS7AbUFhAPAAFAggCBQh+AAEAAgUBAmcACQ0BCgkKYgAAAANfAAMDU0sLBwIGBghfDAEICFRLCwcCBgYEXwAEBFQGTBtLsCFQWEA2AAUCCAIFCH4AAQACBQECZwAEBgYEVwAJDQEKCQpiAAAAA18AAwNTSwsHAgYGCF8MAQgIVAhMG0A0AAUCCAIFCH4AAQACBQECZwwBCAQGCFcABAsHAgYJBAZnAAkNAQoJCmIAAAADXwADA1MATFlZWUAePDwxMQAAPD88Pz49MTsxOgAwAC8iEiQkJBYoDgobKxI1NDY3NzU0JiMiBhUUFxYzMhYVFAYjIiY1NDYzMhYVFRQzMjY1MxQGIyImJycGBiM2Njc1BwYGFRQWMwc1MxU+OicxHRYWIQICBgoMEQsQFjchKTsXEQoOFh4bHgICDCcYKBoKJxoZFQxR8AGcPCIuEhYmHBgSDQYDAw8JDA0SEyEoKC2NJSIaIjMcFgETIB0UE10TDSgXEhNPGBgAAAMARgFqATYCvAAPABsAHwA6QDcHAQMGAQEEAwFnAAQIAQUEBWEAAgIAXwAAAFMCTBwcEBAAABwfHB8eHRAbEBoWFAAPAA4mCQoVKxImJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjMHNTMVnDYgIDYhITggIDghIx4eIyIdHSJ38AGcJ0InJ0InJ0InJ0InEkwyMkxLMzNLRBgYAAIAMP/wAhQCvAAPABsATkuwKlBYQBcAAgIAXwAAACtLBQEDAwFfBAEBATIBTBtAFwACAgBfAAAAK0sFAQMDAV8EAQEBNQFMWUASEBAAABAbEBoWFAAPAA4mBggVKxYmJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjPbbj09bkdGbz09b0ZTNTVTUzU1UxBmpVtbpWZmpVtbpWYgvIqKvLuLi7sAAQB4AAABzAKsABMAa0uwI1BYQBkAAgABAAIBZQADAytLBAEAAAVdAAUFKgVMG0uwKlBYQBkAAwIDgwACAAEAAgFlBAEAAAVdAAUFKgVMG0AZAAMCA4MAAgABAAIBZQQBAAAFXQAFBS0FTFlZQAkRIxIhEyAGCBorNzMyNjURIzUzMjY3MxEUFjMzFSF4YA8NfDc2QwggDQ9g/qwgDA4B6yQ6Kf2ODgwgAAABAEoAAAHwArwAMgCLS7AJUFhAIwABAAQAAQR+AAQDAwRuAAAAAl8AAgIrSwADAwVeAAUFKgVMG0uwKlBYQCQAAQAEAAEEfgAEAwAEA3wAAAACXwACAitLAAMDBV4ABQUqBUwbQCQAAQAEAAEEfgAEAwAEA3wAAAACXwACAitLAAMDBV4ABQUtBUxZWUAJERM7JSsoBggaKzY2Nzc2NjU0JiMiBgYVFBYXFhYVFAYjIiY1NDY2MzIWFhUUBgcHBgYVFDMzMjY3NzMHIVMqSWAvMUxGIDslFhMgHxsYKTYzWzhAZjpWRmIqLR+9KCEGCxYO/no3bD5SJ149TlUeMRoYFwMFIRcTGkE1M1IuMFo9PWIyTB01HBgjIDvQAAEASP/wAfQCvABLAJW1QgEDBgFKS7AqUFhANgAIBwUHCAV+AAYAAwQGA2cABQAEAAUEZwAAAAECAAFnAAcHCV8ACQkrSwACAgpfCwEKCjIKTBtANgAIBwUHCAV+AAYAAwQGA2cABQAEAAUEZwAAAAECAAFnAAcHCV8ACQkrSwACAgpfCwEKCjUKTFlAFAAAAEsASjw6KSQiJCMkIiQkDAgdKxYmNTQ2MzIWFRQGIyIVFDMyNjU0JiMiBgcGIyImNTQ2MzIXFjMyNjU0JiMiBhUUFhcWFRQGIyImNTQ2MzIWFRQGBgcVHgIVFAYGI7BoKiIdIRkUI35JQUUyDxMOIRIPFxYQER4UIzAzPDk7MQ4MJBwaHStrTFtvJzseIUgyQm9DEEVCJDMfGxUfET9kRlBQBAULDg4ODgUDVzhBViYYCRMGDyIVGzEeRkxhTypBKQcIBi1MMT1bMQACADgAAAIOAq0AFAAXAIBACxcBAwIBSgcBAwFJS7AmUFhAGwcBAwQBAQADAWUAAgIrSwUBAAAGXQAGBioGTBtLsCpQWEAbAAIDAoMHAQMEAQEAAwFlBQEAAAZdAAYGKgZMG0AbAAIDAoMHAQMEAQEAAwFlBQEAAAZdAAYGLQZMWVlACxERIxEREhMgCAgcKzczMjY1NSM1ATMRMxUjFRQWMzMVISczEbphDg3+ATYkeXkNDmH+rFTQIAwOhiQByf43JIYODCDkATIAAQBW//ACAgK8AD4Ai0ARMgEFBDMBAwICSiwrJSQEBEhLsCpQWEAtAAMCAAIDAH4AAAECAAF8AAQABQYEBWcAAgIGXwAGBjRLAAEBB18IAQcHMgdMG0AtAAMCAAIDAH4AAAECAAF8AAQABQYEBWcAAgIGXwAGBjRLAAEBB18IAQcHNQdMWUAQAAAAPgA9JiUlJyQqJQkIGysWJiY1NDYzMhYVFAYHBgYVFBYzMjY1NCYjIgYHBgYVFAYjIjURNxYWMzI2NxcGBiMiJicVFzY2MzIWFRQGBiPUUiwwIBsfFBAOEDI8SkJASB0qFgoNCwkQFhVRIzBOKQwkaTslLBUGGEUlaXVDcEMQJ0MpLzIhGREdBwcODCAkgGJcYhEWCiEMCw4ZAVkREhgSGA4vOQkLvwIcH3xmSXZDAAACAFD/8AH2ArwANABBAHi1JwEGBQFKS7AqUFhAJwABAgMCAQN+AAMABQYDBWcAAgIAXwAAACtLCAEGBgRfBwEEBDIETBtAJwABAgMCAQN+AAMABQYDBWcAAgIAXwAAACtLCAEGBgRfBwEEBDUETFlAFTU1AAA1QTVAOzkANAAzKS0nJwkIGCsWJiY1NDY3NjMyFxYWFRQHBiMiJyYmNTQ3Njc2NjU0JiMiBgcGBhUVFzY2MzIXFhYVFAYGIzY2NTQmIyIGBhUUFjPpYzYqKEliRywPDRkRGBcNBQMNCQoJBykqJEEWERIHEksjQy4nKjBdPz03MDgjOCE0PBBQlWVSnjReMBIsESMWDxIHDAoPDwoHBg0JEhsqMSVwJi0DJjEhHF82Nm1IIHRKUGouVTdTawABAFr/8AHoAqwAIQCLS7AJUFhAGAABAAMAAXAAAAACXQACAitLBAEDAzIDTBtLsCNQWEAZAAEAAwABA34AAAACXQACAitLBAEDAzIDTBtLsCpQWEAXAAEAAwABA34AAgAAAQIAZQQBAwMyA0wbQBcAAQADAAEDfgACAAABAgBlBAEDAzUDTFlZWUAMAAAAIQAgERM7BQgXKxYmNTQ2Nzc2NjU0JiMjIgYHByM3IRQGBwcGFRQXFxYVFCP3KzsuUBYdDxDPKCEGCxYOAYAfJTkpBgYIOxA0LDx/QnMfRxoPCyMgO9A0hjdWPEYrICMoHj8AAAMAPP/wAg4CvAAeACwAOgBZQAk0LBYGBAMCAUpLsCpQWEAXAAICAF8AAAArSwUBAwMBXwQBAQEyAUwbQBcAAgIAXwAAACtLBQEDAwFfBAEBATUBTFlAEi0tAAAtOi05JiQAHgAdLgYIFSsWJiY1NDY3NScmJjU0NjYzMhYWFRQGBxUXFhUUBgYjEjY1NCYmIyIGFRQWFxcCNjY1NCYnJwYGFRQWM95lPVIuCzU4QGY3RF8wRS4XdjlvTXckKEMoPlUpLIEJRh8xL4cpLmFBEC5WOklSDQQFFlY5NFUvMU8sNk8VBAkwZz5nPQGlRi8pQyZGOioyEjH+ky5BHTg2EzERSkdQTAACAE7/8AH0ArwANABBAHi1HgEGBQFKS7AqUFhAJwAAAgECAAF+CAEGAAIABgJnAAUFA18AAwMrSwABAQRgBwEEBDIETBtAJwAAAgECAAF+CAEGAAIABgJnAAUFA18AAwMrSwABAQRgBwEEBDUETFlAFTU1AAA1QTVAPDoANAAzJyktJwkIGCsWJyYmNTQ3NjMyFxYWFRQHBgcGBhUUFjMyNjc2NjU1JwYGIyInJiY1NDY2MzIWFhUUBgcGIxI2NjU0JiMiBhUUFjOwLA8NGRIXFw0FAw0JCgkHKSokQRYREgcSSyNDLicqMF0/QWM2KihJYjo4ITQ8PTcwOBAwEiwRIxYPEgcMCg8PCgcGDQkSGyoxJXElLQMmMSEcXzY2bUhQlWVSnjReATQuVTdTa3RKUGoAAAIAHv/2AV4BpAAPABsAKkAnAAAAAgMAAmcFAQMDAV8EAQEBIQFMEBAAABAbEBoWFAAPAA4mBgcVKxYmJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjOPSCkpSC8vSCkpSC81IyM1NSMjNQo2Yj8/YjY2Yj8/YjYZbVFRbW1RUW0AAQBU//4BNAGaABMAULUNAQABAUpLsCpQWEAZAAMCA4MAAgABAAIBZQQBAAAFXQAFBRgFTBtAGQADAgODAAIAAQACAWUEAQAABV0ABQUaBUxZQAkRIxIhEyAGBxorNzMyNjURIzUzMjY3MxEUFjMzFSNUPwkIUCgjKQYWCAk/4BYHCAEVHCkb/osIBxgAAAEANAAAAUgBpAAuAIVLsBJQWEAhAAEABAABBH4ABAMDBG4AAgAAAQIAZwADAwVeAAUFGAVMG0uwKlBYQCIAAQAEAAEEfgAEAwAEA3wAAgAAAQIAZwADAwVeAAUFGAVMG0AiAAEABAABBH4ABAMABAN8AAIAAAECAGcAAwMFXgAFBRoFTFlZQAkREzokKSgGBxorNjY3NzY2NTQmIyIGFRQWFxYVFAYjIiY1NDYzMhYVFAYHBwYGFRQzMzI2NzczByE8GjA/Hh0wLCAwDg0lEhAbI0o4QVE5LEAbHBR6GxMFCQ4J/wEiQCUxFzgmKTYkGQ4NAwUfDA8nIC49PzYlQB0rEhwODg4TJH0AAQBE//YBWgGkAEYAUUBOPgEDBgFKAAgHBQcIBX4ACQAHCAkHZwAGAAMEBgNnAAUABAAFBGcAAAABAgABZwACAgpfCwEKCiEKTAAAAEYARTk3JyQiJCIkIiQkDAcdKxYmNTQ2MzIWFRQGIyIVFDMyNjU0JiMiBwYjIiY1NDYzMhcWMzI2NTQmIyIVFBcWFRQGIyImNTQ2MzIWFRQGBxUeAhUUBiOGQhwWExYQDhlRMCkrIRMUDA8KDw8KDw0OGh8hJiZCEBcSERQcRTA8STQgFi8hXUQKLSkWHhIQDRMKJjgpMTAIBgoKCgoEBDIiJy4nDAcJFA0QHRIrMzowJDIHBQMbLh03QgAAAgAs//4BTgGaABQAFwBgQA8XAQMCDgEAAQJKBwEDAUlLsCpQWEAbAAIDAoMHAQMEAQEAAwFlBQEAAAZdAAYGGAZMG0AbAAIDAoMHAQMEAQEAAwFlBQEAAAZdAAYGGgZMWUALEREjERESEyAIBxwrNzMyNjU1IzUTMxEzFSMVFBYzMxUjJzM1fjcJCJqmNEhICAk30DZ+FgcIURwBCP74HFEIBxiUywAAAQA2//YBTgGkADsAhkARLwEFBDABAwICSikoIiEEBEhLsAlQWEAqAAMCAAIDAH4AAAEBAG4ABAAFBgQFZwAGAAIDBgJnAAEBB2AIAQcHIQdMG0ArAAMCAAIDAH4AAAECAAF8AAQABQYEBWcABgACAwYCZwABAQdgCAEHByEHTFlAEAAAADsAOiYlJSUkKiQJBxsrFiY1NDYzMhYVFAYHBgYVFBYzMjY1NCYjIgYHBgcGIyI1NTcWFjMyNjcXBgYjIiYnFRc2NjMyFhUUBgYjdkAgFhESDwoKCiUlLiwoLxQbDw0CAgwKDg42FyEyGwgYSCYWGhEEEC4YRU0sSiwKNCYcHxQPCxEEBAgHEhVKOTg4Cg0MEREPzwoLDgoPCRwmBwdxARETSz0tRycAAgA2//YBSgGkACwANwBDQEAgAQYFAUoAAQIDAgEDfgAAAAIBAAJnAAMABQYDBWcIAQYGBF8HAQQEIQRMLS0AAC03LTYyMAAsACsoKSYmCQcYKxYmNTQ2NzYzMhYXFhUUBiMiJjU0NzY2NTQmIyIHBgYVFRc2NjMyFhYVFAYGIzY2NTQjIgYVFBYzg00cGTA+FycLFBMTDxIQCAcbGzIbCwoFDi4XJzgdIj4oJyFAIioeJgprWzFfHzkRDRUhEhsQDRMJBAcHCxM4FkEYEgIWGiU7ICRAJxhBLG48MjI7AAABADz/8AE6AZQAIABnS7ASUFhAFgABAAMAAXAAAgAAAQIAZQQBAwMfA0wbS7AqUFhAFwABAAMAAQN+AAIAAAECAGUEAQMDHwNMG0AXAAEAAwABA34AAgAAAQIAZQQBAwMhA0xZWUAMAAAAIAAfERM5BQcXKxYmNTQ3NzY1NCYjIyIGBwcjNzMUBgcHBgYVFBcWFRQGI54ZQzMdCgqBGhUDBw4J9RQXJQoTCQUUFBAWGEhbRScfCQcQESR9H1EhMw4qFhctFBESFwAAAwAo//YBVAGkABwAKQA2ADNAMDApFAUEAwIBSgAAAAIDAAJnBQEDAwFfBAEBASEBTCoqAAAqNio1IyEAHAAbLQYHFSsWJjU0Njc1JyYmNTQ2NjMyFhUUBgcVFxYWFRQGIzY2NTQmIyIGFRQWFxcWNjU0JicnBgYVFBYze1M2HQgiJClCI0FHLB4QIilUSk0UNCgoNxodVAksGh1ZGxw+Kgo/MysuBwMDDTcjIDMcPikgLQ4DBQ0uITpO/ycdJS4mIhkcCx7YMh0iHAwdCikqMCkAAgAy//YBRgGkACwANwBDQEAYAQYFAUoAAAIBAgABfgADAAUGAwVnCAEGAAIABgJnAAEBBF8HAQQEIQRMLS0AAC03LTYzMQAsACsmKCkmCQcYKxYmJyY1NDYzMhYVFAcGBhUUFjMyNzY2NTUnBgYjIiYmNTQ2NjMyFhUUBgcGIzY2NTQmIyIGFRQzjCcLFBMTDxIQBwgbGzIbCwoFDi4XJzgdIj4oP00cGTA+MSoeJichQAoRDRUhEhsQDRMJBAcHCxM4FkEYEgIWGiU7ICRAJ2tbMV8fObs8MjI7QSxuAP//AB4BDgFeArwAAgCdAAD//wBUARYBNAKyAAIAngAA//8ANAEYAUgCvAACAJ8AAP//AEQBDgFaArwAAgCgAAD//wAsARYBTgKyAAIAoQAA//8ANgEOAU4CvAACAKIAAP//ADYBDgFKArwAAgCjAAD//wA8AQgBOgKsAAIApAAA//8AKAEOAVQCvAACAKUAAP//ADIBDgFGArwAAgCmAAAAAgAeAQ4BXgK8AA8AGwAsQCkAAgIAXwAAAFNLBQEDAwFfBAEBAVoBTBAQAAAQGxAaFhQADwAOJgYKFSsSJiY1NDY2MzIWFhUUBgYjNjY1NCYjIgYVFBYzj0gpKUgvL0gpKUgvNSMjNTUjIzUBDjZiPz9iNjZiPz9iNhltUVFtbVFRbQAAAQBUARYBNAKyABMAK0AoDQEAAQFKAAIAAQACAWUAAwNTSwQBAAAFXQAFBVIFTBEjEiETIAYKGisTMzI2NREjNTMyNjczERQWMzMVI1Q/CQhQKCMpBhYICT/gAS4HCAEVHCkb/osIBxgAAAEANAEYAUgCvAAuAF5LsBJQWEAjAAEABAABBH4ABAMDBG4AAAACXwACAlNLAAMDBV4ABQVSBUwbQCQAAQAEAAEEfgAEAwAEA3wAAAACXwACAlNLAAMDBV4ABQVSBUxZQAkREzokKSgGChorEjY3NzY2NTQmIyIGFRQWFxYVFAYjIiY1NDYzMhYVFAYHBwYGFRQzMzI2NzczByE8GjA/Hh0wLCAwDg0lEhAbI0o4QVE5LEAbHBR6GxMFCQ4J/wEBOkAlMRc4Jik2JBkODQMFHwwPJyAuPT82JUAdKxIcDg4OEyR9AAEARAEOAVoCvABGAFNAUD4BAwYBSgAIBwUHCAV+AAYAAwQGA2cABQAEAAUEZwAAAAECAAFnAAcHCV8ACQlTSwACAgpfCwEKCloKTAAAAEYARTk3JyQiJCIkIiQkDAodKxImNTQ2MzIWFRQGIyIVFDMyNjU0JiMiBwYjIiY1NDYzMhcWMzI2NTQmIyIVFBcWFRQGIyImNTQ2MzIWFRQGBxUeAhUUBiOGQhwWExYQDhlRMCkrIRMUDA8KDw8KDw0OGh8hJiZCEBcSERQcRTA8STQgFi8hXUQBDi0pFh4SEA0TCiY4KTEwCAYKCgoKBAQyIicuJwwHCRQNEB0SKzM6MCQyBwUDGy4dN0IAAgAsARYBTgKyABQAFwA4QDUXAQMCDgEAAQJKBwEDAUkHAQMEAQEAAwFlAAICU0sFAQAABl0ABgZSBkwRESMRERITIAgKHCsTMzI2NTUjNRMzETMVIxUUFjMzFSMnMzV+NwkImqY0SEgICTfQNn4BLgcIURwBCP74HFEIBxiUywABADYBDgFOArwAOwC+QBEvAQUEMAEDAgJKKSgiIQQESEuwCVBYQCwAAwIAAgMAfgAAAQEAbgAGAAIDBgJnAAUFBF8ABARTSwABAQdgCAEHB1oHTBtLsBdQWEAtAAMCAAIDAH4AAAECAAF8AAYAAgMGAmcABQUEXwAEBFNLAAEBB2AIAQcHWgdMG0ArAAMCAAIDAH4AAAECAAF8AAQABQYEBWcABgACAwYCZwABAQdgCAEHB1oHTFlZQBAAAAA7ADomJSUlJCokCQobKxImNTQ2MzIWFRQGBwYGFRQWMzI2NTQmIyIGBwYHBiMiNTU3FhYzMjY3FwYGIyImJxUXNjYzMhYVFAYGI3ZAIBYREg8KCgolJS4sKC8UGw8NAgIMCg4ONhchMhsIGEgmFhoRBBAuGEVNLEosAQ40JhwfFA8LEQQECAcSFUo5ODgKDQwREQ/PCgsOCg8JHCYHB3EBERNLPS1HJwAAAgA2AQ4BSgK8ACwANwBFQEIgAQYFAUoAAQIDAgEDfgADAAUGAwVnAAICAF8AAABTSwgBBgYEXwcBBARaBEwtLQAALTctNjIwACwAKygpJiYJChgrEiY1NDY3NjMyFhcWFRQGIyImNTQ3NjY1NCYjIgcGBhUVFzY2MzIWFhUUBgYjNjY1NCMiBhUUFjODTRwZMD4XJwsUExMPEhAIBxsbMhsLCgUOLhcnOB0iPignIUAiKh4mAQ5rWzFfHzkRDRUhEhsQDRMJBAcHCxM4FkEYEgIWGiU7ICRAJxhBLG48MjI7AAEAPAEIAToCrAAgAGtLsBJQWEAYAAEAAwABcAAAAAJdAAICU0sEAQMDWgNMG0uwI1BYQBkAAQADAAEDfgAAAAJdAAICU0sEAQMDWgNMG0AXAAEAAwABA34AAgAAAQIAZQQBAwNaA0xZWUAMAAAAIAAfERM5BQoXKxImNTQ3NzY1NCYjIyIGBwcjNzMUBgcHBgYVFBcWFRQGI54ZQzMdCgqBGhUDBw4J9RQXJQoTCQUUFAEIFhhIW0UnHwkHEBEkfR9RITMOKhYXLRQREhcAAwAoAQ4BVAK8ABwAKQA2ADVAMjApFAUEAwIBSgACAgBfAAAAU0sFAQMDAV8EAQEBWgFMKioAACo2KjUjIQAcABstBgoVKxImNTQ2NzUnJiY1NDY2MzIWFRQGBxUXFhYVFAYjNjY1NCYjIgYVFBYXFxY2NTQmJycGBhUUFjN7UzYdCCIkKUIjQUcsHhAiKVRKTRQ0KCg3Gh1UCSwaHVkbHD4qAQ4/MysuBwMDDTcjIDMcPikgLQ4DBQ0uITpO/ycdJS4mIhkcCx7YMh0iHAwdCikqMCkAAAIAMgEOAUYCvAAsADcAR0BEGAEGBQFKAAACAQIAAX4ABQUDXwADA1NLAAICBl8IAQYGVEsAAQEEXwcBBARaBEwtLQAALTctNjMxACwAKyYoKSYJChgrEiYnJjU0NjMyFhUUBwYGFRQWMzI3NjY1NScGBiMiJiY1NDY2MzIWFRQGBwYjNjY1NCYjIgYVFDOMJwsUExMPEhAHCBsbMhsLCgUOLhcnOB0iPig/TRwZMD4xKh4mJyFAAQ4RDRUhEhsQDRMJBAcHCxM4FkEYEgIWGiU7ICRAJ2tbMV8fObs8MjI7QSxuAAH/gP86ANIC2gADAC5LsBtQWEAMAgEBAAGEAAAAKQBMG0AKAAABAIMCAQEBdFlACgAAAAMAAxEDCBUrBwEzAYABKij+1sYDoPxgAAADAFT/7gMAArwAAwAXAEYAzrEGZES1EQECCAFKS7ASUFhARwAABQCDAAUEBYMACQcMBwkMfgAMCwsMbg4BAQ0BhAAEAAMKBANlAAoACAIKCGcGAQIABwkCB2UACw0NC1UACwsNXgANCw1OG0BIAAAFAIMABQQFgwAJBwwHCQx+AAwLBwwLfA4BAQ0BhAAEAAMKBANlAAoACAIKCGcGAQIABwkCB2UACw0NC1UACwsNXgANCw1OWUAiAABGRURDQD0zMS0rIiAXFhUTEA8NCwoJBgQAAwADEQ8IFSuxBgBEFwEzAQMzMjY1ESM1MzI2NzMRFBYzMxUjBDY3NzY2NTQmIyIGFRQWFxYVFAYjIiY1NDYzMhYVFAYHBwYGFRQzMzI2NzczByGyAawk/lSCPwkIUCgjKQYWCAk/4AGgGjA/Hh0wLCAwDg0lEhAbI0o4QVE5LEAbHBR6GxMFCQ4J/wESAs79MgFABwgBFRwpG/6LCAcY9EAlMRc4Jik2JBkODQMFHwwPJyAuPT82JUAdKxIcDg4OEyR9AAAEAFT/7gMGArwAAwAXACwALwCGsQZkREB7LxECAgomAQgJAkofAQsBSQAABQCDAAUEBYMACgMCAwoCfhABAQ4BhAAEAAMKBANlBgECAAcLAgdlDwELDAEJCAsJZQ0BCA4OCFcNAQgIDl0ADggOTQAALi0sKyooJSQjIiEgHh0aGBcWFRMQDw0LCgkGBAADAAMREQgVK7EGAEQXATMBAzMyNjURIzUzMjY3MxEUFjMzFSMBMzI2NTUjNRMzETMVIxUUFjMzFSMnMzWyAawk/lSCPwkIUCgjKQYWCAk/4AHiNwkImqY0SEgICTfQNn4SAs79MgFABwgBFRwpG/6LCAcY/wAHCFEcAQj++BxRCAcYlMsABABE/+4DBgK8AEYASgBfAGIAn7EGZERAlD4BAwZiAQEAWQENDgNKUgEQAUkACAcFBwgFfhYBDBMMhAsBCQAHCAkHZwAGAAMEBgNnAAUABAAFBGcPAQAAAQIAAWcAAhUBChACCmcUARARAQ4NEA5lEgENExMNVxIBDQ0TXQATDRNNR0cAAGFgX15dW1hXVlVUU1FQTUtHSkdKSUgARgBFOTcnJCIkIiQiJCQXCB0rsQYARBImNTQ2MzIWFRQGIyIVFDMyNjU0JiMiBwYjIiY1NDYzMhcWMzI2NTQmIyIVFBcWFRQGIyImNTQ2MzIWFRQGBxUeAhUUBiMDATMBJTMyNjU1IzUTMxEzFSMVFBYzMxUjJzM1hkIcFhMWEA4ZUTApKyETFAwPCg8PCg8NDhofISYmQhAXEhEUHEUwPEk0IBYvIV1EBwGsJP5UAWA3CQiapjRISAgJN9A2fgEOLSkWHhIQDRMKJjgpMTAIBgoKCgoEBDIiJy4nDAcJFA0QHRIrMzowJDIHBQMbLh03Qv7gAs79MigHCFEcAQj++BxRCAcYlMsAAQBIASIBtgK8AG8APEA5CgEJAQmEBQEDCAEAAQMAaAYBAgcBAQkCAWcABAQrBEwAAABvAG5mZF9dSUdCQDg2LiwnJSUoCwgWKxImNTQ3NjU0JiMiBwYHBgYjIiY1NDY3Njc2NjU0JicmJyYmNTQ2MzIWFxYXFjMyNjU0JyY1NDYzMhYVFAcGFRQWMzI3Njc2NjMyFhUUBgcGBwYGFRQWFxYXFhYVFAYjIiYnJicmIyIGFRQXFhUUBiPtFAwOAwUFCSMVDxkQERQkHyUlAggIAiUlHyQUERAZDxUjCQUFAw4MFBISFAwOAwUFCSMVDxoPERQkHyUlAggIAiUlHyQUEQ8aDxUjCQUFAw4MFBIBIhgTDh0jKgkGBhYbFBMXDhYVBAUVAQYEBAYBFQUEFRYOFxMUGxYGBgkqIx0OExgYEw4dIyoJBgYWGxQTFw4WFQQFFQEGBAQGARUFBBUWDhcTFBsWBgYJKiMdDhMYAAEAOP86AYoC2gADAC5LsBtQWEAMAgEBAAGEAAAAKQBMG0AKAAABAIMCAQEBdFlACgAAAAMAAxEDCBUrBQEzAQFi/tYoASrGA6D8YAABAE4A/gDKAXoACwAeQBsAAAEBAFcAAAABXwIBAQABTwAAAAsACiQDCBUrNiY1NDYzMhYVFAYjcSMjGxsjIxv+IxsbIyMbGyMAAAEAiADwAWwB1AALABlAFgIBAQEAXwAAADQBTAAAAAsACiQDCBUrNiY1NDYzMhYVFAYjykJCMDBCQjDwQjAwQkIwMEIAAgBO//QAygHUAAsAFwAsQCkEAQEBAF8AAAA0SwACAgNfBQEDAzUDTAwMAAAMFwwWEhAACwAKJAYIFSsSJjU0NjMyFhUUBiMCJjU0NjMyFhUUBiNxIyMbGyMjGxsjIxsbIyMbAVgjGxsjIxsbI/6cIxsbIyMbGyMAAQBI/1gA0gCMABUAHEAZFQEARwABAAABVwABAQBfAAABAE8kJwIIFisXNjY1NCYnJiMiJjU0NjMyFxYVFAYHWiUvCAoHGxYcJBYnFhM+LJgcUCgLDQYEHxUbHyAaLT5vIAADAE7/9AL6AHAACwAXACMAL0AsBAICAAABXwgFBwMGBQEBNQFMGBgMDAAAGCMYIh4cDBcMFhIQAAsACiQJCBUrFiY1NDYzMhYVFAYjMiY1NDYzMhYVFAYjMiY1NDYzMhYVFAYjcSMjGxsjIxv9IyMbGyMjG/0jIxsbIyMbDCMbGyMjGxsjIxsbIyMbGyMjGxsjIxsbIwACAE7/9ADKArYAEAAcAC9ALA4AAgEAAUoAAQACAAECfgAAACtLAAICA18EAQMDNQNMERERHBEbJRcmBQgXKxMmJyY1NDYzMhYVFAcGBwcjBiY1NDYzMhYVFAYjcAMOESIcHCIRDgMQGA8jIxsbIyMbAWQrS142IScnITZeSyvIqCMbGyMjGxsjAAACAE7/EgDKAdQACwAcADZAMxUSAgMCAUoAAgEDAQIDfgQBAQEAXwAAADRLBQEDAzYDTAwMAAAMHAwbFBMACwAKJAYIFSsSJjU0NjMyFhUUBiMCJjU0NzY3NzMXFhcWFRQGI3EjIxsbIyMbHCIRDgMQGBADDhEiHAFYIxsbIyMbGyP9uichNl5LK8jIK0teNiEnAAIAUQAAAmICrAAbAB8Ap0uwI1BYQCYHBQIDDwgCAgEDAmYOCQIBDAoCAAsBAGUGAQQEK0sQDQILCyoLTBtLsCpQWEAmBgEEAwSDBwUCAw8IAgIBAwJmDgkCAQwKAgALAQBlEA0CCwsqC0wbQCYGAQQDBIMHBQIDDwgCAgEDAmYOCQIBDAoCAAsBAGUQDQILCy0LTFlZQB4AAB8eHRwAGwAbGhkYFxYVFBMRERERERERERERCB0rMzcjNTM3IzUzNzMHMzczBzMVIwczFSMHIzcjBzczNyOmH3R5JJ2jHSwekh4sHoWKIqmxHiwekR8klCKSxCjWKMLCwsIo1ijExMTs1gAAAQBO//QAygBwAAsAGUAWAAAAAV8CAQEBNQFMAAAACwAKJAMIFSsWJjU0NjMyFhUUBiNxIyMbGyMjGwwjGxsjIxsbIwACAED/9AGsArYAPgBKAElARjg3AgUDAUoCAQEAAwUBA2cABQkBBgcFBmcAAAAEXwAEBCtLAAcHCF8KAQgINQhMPz8AAD9KP0lFQwA+AD0rJSQiJisLCBorNiY1NDY3NzY2NTQmIyIGBhUUFxYzMjc2MzIWFRQGIyImNTQ2NjMyFhYVFAYGBwYVFBYzMjY1NCc3FhUUBgYjBiY1NDYzMhYVFAYj0TMXGUwdHTo5HjYhBgUFBwMHCxETHBscKTJOKDRaNio7LlkfGRoiBRILGSgTGyMjGxsjIxuaKiceKhtSIDgmNUUWJBQXBgQBAhcRFRsvKCdAJCNFMClEMiA9OhkXJB4QCggSERssGKYjGxsjIxsbIwACACL/EgGOAdQACwBKAE5ASx4dAgcCAUoAAwACBwMCZwAHBgEFBAcFZwkBAQEAXwAAADRLAAQECF8KAQgINghMDAwAAAxKDElEQj48OjgyMCUjGRcACwAKJAsIFSsSJjU0NjMyFhUUBiMCJiY1NDY2NzY1NCYjIgYVFBcHJjU0NjYzMhYVFAYHBwYGFRQWMzI2NjU0JyYjIgcGIyImNTQ2MzIWFRQGBiO7IyMbGyMjGyRaNio7LlkfGRoiBRILGSgTJzMXGUwdHTo5HjYhBgUFBwMHCxETHBscKTJOKAFYIxsbIyMbGyP9uiNFMClEMiA9OhkXJB4QCggSERssGConHiobUiA4JjVFFiQUFwYEAQIXERUbLygnQCQAAAIAVgIIATQC2gAKABUAP0AJEgwHAQQBAAFKS7AqUFhADQMBAQEAXwIBAAAxAUwbQBMCAQABAQBXAgEAAAFdAwEBAAFNWbYUJBQjBAgYKxMnNDYzMhYVBwcjNyc0NjMyFhUHByNYAhMPDxMCFBiGAhMPDxMCFBgCmhIXFxcXEpKSEhcXFxcSkgABAFYCCACaAtoACgA1tgcBAgEAAUpLsCpQWEALAAEBAF8AAAAxAUwbQBAAAAEBAFcAAAABXQABAAFNWbQUIwIIFisTJzQ2MzIWFQcHI1gCEw8PEwIUGAKaEhcXFxcSkgACAEj/WADSAdQACwAhAChAJSEBAkcAAwACAwJjBAEBAQBfAAAANAFMAAAbGRUTAAsACiQFCBUrEiY1NDYzMhYVFAYjAzY2NTQmJyYjIiY1NDYzMhcWFRQGB3EjIxsbIyMbMiUvCAoHGxYcJBYnFhM+LAFYIxsbIyMbGyP+EBxQKAsNBgQfFRsfIBotPm8gAAABADj/OgGKAtoAAwAuS7AbUFhADAIBAQABhAAAACkATBtACgAAAQCDAgEBAXRZQAoAAAADAAMRAwgVKxcBMwE4ASoo/tbGA6D8YAAAAQAA/2ICCP+KAAMAJrEGZERAGwAAAQEAVQAAAAFdAgEBAAFNAAAAAwADEQMIFSuxBgBEFTUhFQIInigoAAABAGj/PAFQAtoALwAoQCUhAQABAUoWFQIBSC8uAgBHAAEAAAFXAAEBAF8AAAEATxEYAggWKxY1NDY3NjU0JiM1MjY2NTQnJiY1NDcXBgYVFBYXFhYVFAcVFhYVFAYHBgYVFBYXB64JChE0NiUsGREKCZYMMzMJCQkJXig2CQkJCTMzDJN3GC8kPCMyIhIKIiIiQCguGHcxGBImJhgsIyAvGGweAg1EPxgsICAsGCYmEhgAAQBU/zwBPALaAC8AKUAmCwEBAAFKGBcCAEgvAQFHAAABAQBXAAAAAV8AAQABTyUkIyICCBQrFzY2NTQmJyYmNTQ3NSY1NDY3NjY1NCYnNxYVFAYHBhUUFhYzFSIGBhUUFxYWFRQHVDMzCQkJCV5eCQkJCTMzDJYJChEZLCUlLBkRCgmWrBImJhgsIyMsGGweAh5sGC8gIywYJiYSGDF3GC4oQCIiIgoSCiIiIkAoLhh3MQAAAQB4/zoBNgLaAA0ALkuwKlBYQAwCAQEAAYQAAAApAEwbQAoAAAEAgwIBAQF0WUAKAAAADQANEQMIFSsXETcXBwYGFREUFhcXB3i6BGALCwsLYAS6A4gMGhABEg389A0SARAaAAEARv86AQQC2gANACZLsCpQWEALAAEAAYQAAAApAEwbQAkAAAEAgwABAXRZtBEaAggWKxc3NjY1ETQmJyc3FxEHRmALCwsLYAS6uqwQARINAwwNEgEQGgz8eAwAAQBi/zoBRALaAA0ABrMNBQEwKxYmNTQ2NxcGBhUUFhcHzWtrWR5ZV1dZHnTxjY3xUhhd2oGB2l0YAAEAMP86ARIC2gANAAazDQcBMCsXNjY1NCYnNxYWFRQGBzBZV1dZHllra1muXdqBgdpdGFLxjY3xUgABADwA9AOsARgAAwAeQBsAAAEBAFUAAAABXQIBAQABTQAAAAMAAxEDCBUrNzUhFTwDcPQkJAABADwA9AIwARgAAwAeQBsAAAEBAFUAAAABXQIBAQABTQAAAAMAAxEDCBUrNzUhFTwB9PQkJAABADwA4AE2ARgAAwAeQBsAAAEBAFUAAAABXQIBAQABTQAAAAMAAxEDCBUrNzUzFTz64Dg4AAABADwA4AE2ARgAAwAeQBsAAAEBAFUAAAABXQIBAQABTQAAAAMAAxEDCBUrNzUzFTz64Dg4AAACAGwAHAFuAawADQAbAAi1GxMNBQIwKzYmNTQ2NxcGBhUUFhcHNiY1NDY3FwYGFRQWFwezR0ctDyQnJyQPYDc3IA4bGhobDjlqQUFqHQ8gYjc3YiAPLF89PV8aDiJRNTVRIg4AAgByABwBdAGsAA0AGwAItRsVDQcCMCs3NjY1NCYnNxYWFRQGByc2NjU0Jic3FhYVFAYH8SQnJyQPLUdHLY4bGhobDiA3NyArIGI3N2IgDx1qQUFqHSAiUTU1USIOGl89PV8aAAEAbAAcAO8BrAANAAazDQUBMCs2JjU0NjcXBgYVFBYXB7NHRy0PJCcnJA85akFBah0PIGI3N2IgDwABAFsAHADeAawADQAGsw0HATArNzY2NTQmJzcWFhUUBgdbJCcnJA8tR0ctKyBiNzdiIA8dakFBah0AAgBI/1gBjACMABUAKwAiQB8rFQIARwMBAQAAAVcDAQEBAF8CAQABAE8kLiQnBAgYKxc2NjU0JicmIyImNTQ2MzIXFhUUBgc3NjY1NCYnJiMiJjU0NjMyFxYVFAYHWiUvCAoHGxYcJBYnFhM+LKwlLwgKBxsWHCQWJxYTPiyYHFAoCw0GBB8VGx8gGi0+byAQHFAoCw0GBB8VGx8gGi0+byAAAgBGAaYBigLaABUAKwAxQC4dHAcGBABIAgEAAQEAVwIBAAABXwUDBAMBAAFPFhYAABYrFiomJAAVABQuBggVKxInJjU0NjcXBgYVFBYXFjMyFhUUBiMyJyY1NDY3FwYGFRQWFxYzMhYVFAYjbxYTPiwOJS8ICgcbFhwkFpMWEz4sDiUvCAoHGxYcJBYBpiAaLT5vIBAcUCgLDQYEHxUbHyAaLT5vIBAcUCgLDQYEHxUbHwAAAgBIAaYBjALaABUAKwA6tCsVAgBHS7AqUFhADQIBAAABXwMBAQExAEwbQBMDAQEAAAFXAwEBAQBfAgEAAQBPWbYkLiQnBAgYKxM2NjU0JicmIyImNTQ2MzIXFhUUBgc3NjY1NCYnJiMiJjU0NjMyFxYVFAYHWiUvCAoHGxYcJBYnFhM+LKwlLwgKBxsWHCQWJxYTPiwBthxQKAsNBgQfFRsfIBotPm8gEBxQKAsNBgQfFRsfIBotPm8gAAABAEYBpgDQAtoAFQAjQCAHBgIASAAAAQEAVwAAAAFfAgEBAAFPAAAAFQAULgMIFSsSJyY1NDY3FwYGFRQWFxYzMhYVFAYjbxYTPiwOJS8ICgcbFhwkFgGmIBotPm8gEBxQKAsNBgQfFRsfAAABAEgBpgDSAtoAFQAysxUBAEdLsCpQWEALAAAAAV8AAQExAEwbQBAAAQAAAVcAAQEAXwAAAQBPWbQkJwIIFisTNjY1NCYnJiMiJjU0NjMyFxYVFAYHWiUvCAoHGxYcJBYnFhM+LAG2HFAoCw0GBB8VGx8gGi0+byAAAAEASP9YANIAjAAVABxAGRUBAEcAAQAAAVcAAQEAXwAAAQBPJCcCCBYrFzY2NTQmJyYjIiY1NDYzMhcWFRQGB1olLwgKBxsWHCQWJxYTPiyYHFAoCw0GBB8VGx8gGi0+byAAAgBw/4gB0gJAACcALgA9QDooHQoHBAEALgECAwJKAAEEAUkAAAEAgwABAwGDAAMCA4MABQQFhAACAgRfAAQENQRMERISHCcYBggaKwUmJjU0NjY3NTMVHgIVFAYjIiY1NDY3NjU0JiYnETY2NzMGBgcVIxEGBhUUFhcBIlReLlEzICo+ICAXFBsUDhASJhw4OQcYBEhEIC8rKTELCYZgPmlDBW1tAyg5Hh8jGhISGAQFDQscFwL+UQNUOUBlA2wCMgx+TEx7DgACADQAaQIQAkUAIQAxAElARhEHAgIAIBoXEg8JBgEIAwIYAQEDA0oQCAIASCEZAgFHAAAAAgMAAmcEAQMBAQNXBAEDAwFfAAEDAU8iIiIxIjAqLysFCBcrNzcmNTQ2Nyc3FzY2MzIWFzcXBxYWFRQHFwcnBgYjIiYnByQ2NjU0JiYjIgYGFRQWFjM0QzEaGEQfQx1IJydIHUMfRBgaMUMfQx1IJydIHUMBAlIvL1IzM1IvL1IziEM8TydIHUQfQxgaGhhDH0QdSCdPPEMfQxgaGhhDOS9SMzNULy9UMzNSLwAABQA+/6wB9gL2AE0AVABcAGMAawC1QCklIh4bBAgCVVJOPAQECGpgX1tUUz0UCAAEa2FeEwQJAEtHRAAEBgkFSkuwKlBYQDEDAQECAYMABAgACAQAfgAACQgACXwHAQUGBYQACAgCXwACAitLCgEJCQZfAAYGMgZMG0AxAwEBAgGDAAQIAAgEAH4AAAkIAAl8BwEFBgWEAAgIAl8AAgIrSwoBCQkGXwAGBjUGTFlAGl1dXWNdYlFPTUxKSEZFLy0kIyEfHRwmCwgVKxcmJjU0NzYzMhcWFRQGBwYVFBYXEScmJjU0Njc1MxU2MzIXNTMVFhYVFAYHBgYjIiYnJjU0Njc2NjU0JicRFxYWFRQGBxUjNQYjIicVIxMmIyIHFRcDBgYVFBYXFxI3EScRFjM2NjU0JicnEeROWBgSGhAODA4WDDYyBkVDSUUgFAwQCCBJUQYIBxkPCw4ICREMCgszMhQ/RU9JIAgQFgogWAgQDBQ4WDAuJTMGUAg4ChZsOCouFAsOW0cjGBIMDBQRGRgMFRorCQE4AhtdPz9gEEE8AgE7Pw1aOBYgDgwOBggLDhIaCwkTERcxCv7kCBljPEhtEEpFAQFFAu8BAvwWAQwOQycrMBQC/mUBARkW/tEBFUsrNDMTCP76AAABACL/8AIgArwAOAC0S7AqUFhARAAFCAcIBQd+AA4ADQAODX4JAQMKAQIBAwJlCwEBDAEADgEAZQAICARfAAQEK0sABwcGXQAGBitLAA0ND18QAQ8PMg9MG0BEAAUIBwgFB34ADgANAA4NfgkBAwoBAgEDAmULAQEMAQAOAQBlAAgIBF8ABAQrSwAHBwZdAAYGK0sADQ0PXxABDw81D0xZQB4AAAA4ADc1NDIwLSwrKiYlJCMiERMjIxEUERMRCB0rBCYmJyM3MyY1NDcjNzM+AjMyFxYWMzI2NzczFSMmJiMiBgczByMGFRQXMwcjFBYWMzI2NzMGBiMBEHhHCCcGHwEBJQYiC0lxQz44ChQHCAcCCxcYFWQ9R1IG9gfxAQHnBuArTjRDVA0aDl1TEE6JVyAHEBYLIFOGTS4IDQkIK9xWbYp8IA4TDQogTHtHWkFLcAAAAgBA/+4CfgK8AFEAXADPQCFAOx4DAgNFGAIIB09OAgEIVEgNAgQJCwRKGQECQQEHAklLsCpQWEBBAAUGAwYFA34AAwACBwMCZwAHAAgBBwhnAAEACwkBC2cABgYEXwAEBCtLDgEMDABfAAAANUsACQkKXw0BCgoyCkwbQEEABQYDBgUDfgADAAIHAwJnAAcACAEHCGcAAQALCQELZwAGBgRfAAQEK0sOAQwMAF8AAAA1SwAJCQpfDQEKCjUKTFlAHFJSAABSXFJbWFYAUQBQTEokJSklJiUoJCQPCB0rBCYnBgYjIiY1NDYzMhc2NjU0JicmIyIGByc2NjMyFyY1NDY2MzIWFhUUBiMiJjU0NzY2NTQmIyIGBhUVFjMyNjcXBiMiJxUUBxYWMzI2NxcGIyQ2NyYmIyIGFRQzAaZZNhZBHik5OyEzPAYDBAM0DRodFQ4PJR4TNAE7ZTo0QBseHhUdGQ0KJyoeOyYqExofEw4cNhE0MCZpLy1CChIjkP7vMg8dLhoZIUYSKSIZLCcnIy0dGSYkHFIbCQoMFg0PCg4kSnxIKzoWIikaFSANBwsLEyAkTjqKCAsLFhwJQWxFFxhLLQezHiYdFRYhFzYAAQAOAAACNAKsADYAwbYZFgIEBQFKS7AjUFhALgsBBAwBAwIEA2UNAQIOAQEAAgFlCggHAwUFBl0JAQYGK0sPAQAAEF0AEBAqEEwbS7AqUFhALAkBBgoIBwMFBAYFZwsBBAwBAwIEA2UNAQIOAQEAAgFlDwEAABBdABAQKhBMG0AsCQEGCggHAwUEBgVnCwEEDAEDAgQDZQ0BAg4BAQACAWUPAQAAEF0AEBAtEExZWUAcNjU0Mi8uLSwrKikoJSMiISkhESMRERESIBEIHSs3MzI1NSM1MzUjNTMDJiYjIzUzFSMiFRQXFzc2NTQmIyM1MxUjIgYHBzMVIxUzFSMVFBYzMxUhiEocjIyMhosJExAj5CEbCHltFA8TKsgWFiUUiYyMjIwND0r+3CAchiBIIAEbExQgIBEHEvbGJBMNFiAgKSL3IEgghg4OIAABADD/7gIAArwAAwAGswEAATArFwEzATABrCT+VBICzv0yAAABADD/ZAN8AqwACwBQS7AjUFhAFgYBBQAFhAMBAQQBAAUBAGUAAgIrAkwbQB4AAgECgwYBBQAFhAMBAQAAAVUDAQEBAF0EAQABAE1ZQA4AAAALAAsREREREQcIGSsFESE1IREzESEVIREBwP5wAZAsAZD+cJwBkCgBkP5wKP5wAAEAMAD0A3wBHAADAAazAQABMCs3NSEVMANM9CgoAAEAnP/OAxACQgALAAazBAABMCsXJwEBNwEBFwEBBwG8IAEb/uUgARoBGiD+5QEbIP7mMiABGgEaIP7lARsg/ub+5iABGwADADD/yAN8AkQACwAPABsAQEA9AAAGAQECAAFnAAIHAQMEAgNlAAQFBQRXAAQEBV8IAQUEBU8QEAwMAAAQGxAaFhQMDwwPDg0ACwAKJAkIFSsAJjU0NjMyFhUUBiMFNSEVACY1NDYzMhYVFAYjAbsjIxsbIyMb/loDTP4/IyMbGyMjGwHIIxsbIyMbGyPUKCj+1CMbGyMjGxsjAAACADAAlAN8AXoAAwAHAC9ALAAABAEBAgABZQACAwMCVQACAgNdBQEDAgNNBAQAAAQHBAcGBQADAAMRBggVKxM1IRUFNSEVMANM/LQDTAFSKCi+KCgAAAEAUP9kA1gCrAAGAAazBAABMCsXJwEBNwEVZBQCyv02FAL0nCQBgAGAJP5qHAABAFT/ZANcAqwABgAGswMAATArBQE1ARcBAQNI/QwC9BT9NgLKnAGWHAGWJP6A/oAAAAIAMP/YA3wCjAALAA8AQkA/AAIBAoMIAQUABgAFBn4DAQEEAQAFAQBlAAYHBwZVAAYGB10JAQcGB00MDAAADA8MDw4NAAsACxERERERCggZKyURITUhETMRIRUhEQU1IRUBwP5wAZAsAZD+cP5EA0RAARIoARL+7ij+7mgoKAAAAQAwAKMCZAFnACUAPLEGZERAMREBAwAkAQIBAkoSAQBIJQECRwAAAAMBAANnAAECAgFXAAEBAl8AAgECTyQrJCQECBgrsQYARDYmNTQ2MzIWFxYWMzI2NTQmJzcWFhUUBiMiJicmJiMiBhUUFhcHUSE8NipfRz5NHRAYFhQMHyE8NitiQz1OHRAYFhQMsS8dKDshHxwcGRUVHAsVDi8dKDshHxwcGRUVHAsVAAEAMACgAhQBbgAFACRAIQMBAgAChAABAAABVQABAQBdAAABAE0AAAAFAAUREQQIFislNSE1IRUB6P5IAeSgpijOAAEAPv7mAkIB0gBFAEBAPTozLCYSBgYDAAFKBwEGBAaEAgEAADRLAAMDBF8FAQQENUsAAQEEXwUBBAQ1BEwAAABFAEQkJicpJysICBorEiY1NDc2NSYmNTQ2MzIVFAcGBxYWMzI2NjU0JyYmNTQzMhYVFAYHFhYzMjY3FhUUBiMiJwcGBiMiJicGFRQWFxYWFRQGI2IgDAoJERYeLBsJAgpDLi45GAkFBjQdGxkSCyYTHyUFFiIfPygHEkU0NlEUBRUVCwsXEf7mQCM8cF0yIHtDMT1YIpYvFCgzKTQRGzshSRRuQDY0oS4SEycaGxwhKU8BHy06KSAbTlUoFhwNFhgAAAUAYP/uAvwCvgADABMAHwAvADsAkEuwKlBYQCwMAQULAQMGBQNnAAYACAkGCGcABAQAXwIBAAArSw4BCQkBXw0HCgMBATIBTBtALAwBBQsBAwYFA2cABgAICQYIZwAEBABfAgEAACtLDgEJCQFfDQcKAwEBNQFMWUAqMDAgIBQUBAQAADA7MDo2NCAvIC4oJhQfFB4aGAQTBBIMCgADAAMRDwgVKxcBMwECJiY1NDY2MzIWFhUUBgYjNjY1NCYjIgYVFBYzACYmNTQ2NjMyFhYVFAYGIzY2NTQmIyIGFRQWM8YBqiT+Vio+IiM9JiY/IyM/JiwcHSsrGxsrAWg+IiM9JiY/IyM/JiwcHSsrGxsrEgLQ/TABaC5SMjJTLy9TMjJSLhRTS0tVVExMUv6GLlIyMlMvL1MyMlIuFFNLS1VUTExSAAEAMP9iAUgCrgALAAazCgQBMCsTByc2NzMWFwcnESOoaw1hJQwlYQ1rKAI4Xg5qXFxqDl79KgAAAQAw/2IBSAKuAAsABrMKBAEwKxYnNxcRMxE3FwYHI5FhDWsoaw1hJQxCag5eAtb9Kl4OalwAAgAw/+4C/gLaAEEAUwCVQAwiEgIFCT49AgcBAkpLsCpQWEAxAAQDCQMECX4AAwAJBQMJZwwKAgUCAQEHBQFnAAYGAF8AAAAxSwAHBwhfCwEICDIITBtALwAEAwkDBAl+AAAABgMABmcAAwAJBQMJZwwKAgUCAQEHBQFnAAcHCF8LAQgINQhMWUAZQkIAAEJTQlJLSQBBAEAmJiUUJyUmJg0IHCsEJiY1NDY2MzIWFhUUBgYjIiYnJwYGIyImNTQ2NzY2MzIWFzM3MwMGFRQWMzI2NjU0JiYjIgYGFRQWFjMyNxcGBiMmNjc3NjU0JiMiBgcGBhUUFjMBKqNXY6tmbZxRM2dKJjUEBRFAJy1DIiEqXCoaKQQFC0hUBhYOPUodTItcVpFUTZJlWFgQIWVEJVEUFwUdGCg/HhIYHhISXqluZqxlXaFjNnJOKCMBGjJAPD98JzMvJhEr/soYExsgTG44X4pIYKhnZJJPOhcYJ61qSlUSEyY8N0EndzYfJQAAAwA2/+4C3AK/ADYAQwBPAJZAFUMBAgcUBgIBAkdFMy4tJxUHBAEDSkuwKlBYQC0AAgMBAQQCAWcABwcAXwAAACtLAAQEBV8JBgIFBTJLCgEICAVfCQYCBQUyBUwbQC0AAgMBAQQCAWcABwcAXwAAACtLAAQEBV8JBgIFBTVLCgEICAVfCQYCBQU1BUxZQBdERAAARE9ETj07ADYANSUnIREsLQsIGisWJjU0Njc3JyYmNTQ2NjMyFhUUBgcXNzY2NTQmIyM1MxUjIgYHBgYHFhYzMjY3FwYGIyInBgYjEjY1NCYjIgYVFBYXFxI3JycHBgYVFBYWM55oVDoeChgcK0YpOjtBO6wEIy4XEC34HxspEicvGiMxGCUsEBAVPTZGSCllN1k9LiIpMiITCjZQEqEKJjAjMxkSUlE5ZCwXDyRNITJPLEkyOFQv9AUrZB0SFiAgFCVPTSAxLioiCC1DUSQtAdxKNiM0PzIgRBkN/mZLF+cIHlVBLz8fAAABAED/ZAHcAsgAEABOS7AqUFhAGQAAAgMCAAN+BQEDA4IEAQICAV0AAQEpAkwbQB4AAAIDAgADfgUBAwOCAAECAgFVAAEBAl0EAQIBAk1ZQAkRERERJRAGCBorEyImNTQ2NjMzFSMRIxEjESPoSV8sTS/0RCZkJgGCV0cvTSwi/L4DQvy+AAIAZP9GAdYCvABKAFoAP0A8WlNDHgQAAwFKAAMEAAQDAH4AAAEEAAF8AAEGAQUBBWMABAQCXwACAisETAAAAEoASTc1KyklIyolBwgWKxYmJjU0NjMyFhUUBgcGBhUUFjMyNjU0JicnJiY1NDcmNTQ2NjMyFhUUBiMiJjU0Njc2NjU0JiMiBhUUFhcXFhYVFAYHFhYVFAYGIxI2NTQmJycmJwYVFBcXFhfxNyIeGBMdCw0HBR4WJDYfI4AiIG48KkQmLkgeFhUdDA4GBB0XJDYfJYAlHT4wGiApRCdoOhUXjAgMWiqMDgi6Gy8cGhwZERARCAQHCA4QKiQnOR5sHz0sTkY2Sik/IjspGh4aEg8PCgQHBw8PKSUrMiFuHzovLEcfHEMlKT0gASo1FR8tEngGDjgmNyV2DAoAAwAw/+4DBALaAA8AHwBCAHWxBmREQGoABQgHCAUHfgAKBwkHCgl+AAAAAgQAAmcABAAIBQQIZwAGAAcKBgdlAAkOAQsDCQtnDQEDAQEDVw0BAwMBXwwBAQMBTyAgEBAAACBCIEE/Pjw6NzUyMTAvLSsoJhAfEB4YFgAPAA4mDwgVK7EGAEQEJiY1NDY2MzIWFhUUBgYjPgI1NCYmIyIGBhUUFhYzLgI1NDY2MzIXFhYzMjY1MxUjLgIjIhUUFjMyNjczBgYjATWmX1+mZWWmX1+mZVyZWVmZXFyZWVmZXDRcLjFcPygqBgcHCQ0SEgQoOBh0Njw9PAcYBE1HEmWrZmarZWWrZmarZRxen11dn15en11dn15kQmk5SXNAIQUCFgykJkQo5EuBVDxCZgAEADD/7gMEAtoADwAfAFAAXACIsQZkREB9QgEEDQFKAAsEBQQLBX4AAAACCQACZwAJDgEIDQkIZxIBDQAECw0EZQcBBQAGDAUGZQAKEQEMAwoMZxABAwEBA1cQAQMDAV8PAQEDAU9SUSAgEBAAAFlWUVxSXCBQIE9NTEpIPTs6ODMxMC8uLCknEB8QHhgWAA8ADiYTCBUrsQYARAQmJjU0NjYzMhYWFRQGBiM+AjU0JiYjIgYGFRQWFjM2JyYmJy4CIyMVFBYzMxUjNTMyNjURNCYjIzUzMhYVFAYHFRYWFxYWMzI2NTMUBiMDMjY1NCYjIyIGFRUBNaZfX6ZlZaZfX6ZlXJlZWZlcXJlZWZlcgBQPEwMEDRwaSgoMLMoqDAoKDCrkP1NLJTAqBgUNEhgSEiMynCEoIyc2DAoSZatmZqtlZatmZqtlHF6fXV2fXl6fXV2fXmwOCzYkMDMatgwKGBgKDAFsDAoYOTU0MwUEDUg1KyE+IC9PAQguKisxCgyeAAIAHgEmA64CyAAjAE4ACLVNNiIQAjArEzMyNjURNCYjIgYHBgYVIzchFyM0JicmJiMiBhURFBYzMxUjAREUFjMzFSM1MzI2NRE0JiMjNTMTEzMVIyIGFREUFjMzFSM1MzI2NREDI3IqDAoKDB4hDQ8PFAcBYwYUDw8NIR4MCgoMKsgBthAWFJAUFhAKDCSKZl2PJAwKCgwkvCQMCngSAUYKDAE+DAoZGR5BB7CwB0EeGRkKDP7CDAoYAVb++BsbGBgbGwEeDAoY/tkBJxgKDP7CDAoYGAoMATj+kgACAJoBrAGqArwADwAbADixBmREQC0AAAACAwACZwUBAwEBA1cFAQMDAV8EAQEDAU8QEAAAEBsQGhYUAA8ADiYGCBUrsQYARBImJjU0NjYzMhYWFRQGBiM2NjU0JiMiBhUUFjP9PyQkPyUlPyQkPyUtOzstLTs7LQGsJD8lJT8kJD8lJT8kIDstLTs7LS07AAABAHj/OgCkAtoAAwAuS7AbUFhADAIBAQABhAAAACkATBtACgAAAQCDAgEBAXRZQAoAAAADAAMRAwgVKxcRMxF4LMYDoPxgAAACAHj/WACkAtoAAwAHAFBLsBtQWEAbBAEBAAIAAQJ+AAIDAAIDfAUBAwOCAAAAKQBMG0AVAAABAIMEAQECAYMAAgMCgwUBAwN0WUASBAQAAAQHBAcGBQADAAMRBggVKxMRMxEDETMReCwsLAFyAWj+mP3mAWj+mAABAD4BUAIGArwABQAgsQZkREAVBAECAEgCAQIAAHQAAAAFAAUSAwgVK7EGAEQbAiMDAz7m4jCytgFQAWz+lAEe/uIAAAEALAHIAPACvAADABFADgEBAEcAAAArAEwSAQgVKxMnNzNEGHFTAcgK6gAAAgAsAcgBmAK8AAMABwAUQBEFAQIARwEBAAArAEwTEgIIFisTJzczByc3M0QYcVMEGHFTAcgK6vQK6gAAAQAoAegAoALQABMAJLEGZERAGRMBAEcAAQAAAVcAAQEAXwAAAQBPJCYCCBYrsQYARBM2NjU0JyYjIiY1NDYzMhYVFAYHKh8tCggUEhYfFx4kPysB9A80FxAIBh4SGRsrITJVFQAAAQAoAegAoALQABMAK7EGZERAIAYFAgBIAAABAQBXAAAAAV8CAQEAAU8AAAATABIsAwgVK7EGAEQSJjU0NjcXBgYVFBcWMzIWFRQGI0wkPysMHy0KCBQSFh8XAegrITJVFQwPNBcQCAYeEhkbAAABAGQB/AENAqwACgAXsQZkREAMCgEARwAAAHQjAQgVK7EGAEQTNzY2MzIWFRQHB2RcDRYODQ8cgAIHhRIOEQ4XFWUAAAEAZP8sAR4AAAAZAHGxBmRES7AZUFhAJwADBAQDbgAAAgECAAF+AAQAAgAEAmgAAQUFAVcAAQEFXwYBBQEFTxtAJgADBAODAAACAQIAAX4ABAACAAQCaAABBQUBVwABAQVfBgEFAQVPWUAOAAAAGQAYIREjIiQHCBkrsQYARBYmNTQ2MzIXFjMyNjU0IyM3MwczMhYVFAYjlzMOChcEByEcHTopEBcIGiEvMDbUIR4LECAoGRcwYjIlIyU1AAABAGQB/AFqAqAACgAasQZkREAPCggGBQQARwAAAHQSAQgVK7EGAEQTNjczFhcHJicGB2RLJCgkSwlFNTZEAgkxZmYxDSQ4OSMAAAIAZAIkAYAChAALABcAMrEGZERAJwIBAAEBAFcCAQAAAV8FAwQDAQABTwwMAAAMFwwWEhAACwAKJAYIFSuxBgBEEiY1NDYzMhYVFAYjMiY1NDYzMhYVFAYjgR0dExQcHBSpHR0TFBwcFAIkHRMUHBwUEx0dExQcHBQTHQABAGQB/AENAqwACgAYsQZkREANCgkCAEcAAAB0JAEIFSuxBgBEEyY1NDYzMhYXFweAHA8NDhYNXA0CYRUXDhEOEoULAAEAZAI8AWgCZAADACaxBmREQBsAAAEBAFUAAAABXQIBAQABTQAAAAMAAxEDCBUrsQYARBM1IRVkAQQCPCgoAAACAGQB9AEoArgACwAXADixBmREQC0AAAACAwACZwUBAwEBA1cFAQMDAV8EAQEDAU8MDAAADBcMFhIQAAsACiQGCBUrsQYARBImNTQ2MzIWFRQGIzY2NTQmIyIGFRQWM546OigpOTkpHysrHx8rKx8B9DooKTk5KSg6GCsfHysrHx8rAAABAGQCKgGAAowAFwAzsQZkREAoDAsCAEgXAQJHAAEDAgFXAAAAAwIAA2cAAQECXwACAQJPJCQkIgQIGCuxBgBEEzY2MzIWFxYWMzI3FwYGIyImJyYmIyIHZAYsJBMiFhMaDyIMEQYsJBMiFhMaDyIMAi4kNAsJCAgqBCQ0CwkICCo=) format('truetype');
}
body {font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'source-han-serif-sc', 'Source Han Serif SC', 'Source Han Serif CN', 'Source Han Serif TC', 'Source Han Serif TW', 'Source Han Serif', 'Songti SC', 'Microsoft YaHei', serif;}blockquote {font-family: 'Old Standard TT', Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'STKaiti', 'KaiTi', '楷体', 'SimKai', 'DFKai-SB', 'NSimSun', serif;}code {font-family: Consolas, Courier, "Courier New", 'STKaiti', 'KaiTi', 'SimKai', monospace;}pre, code {font-size: .95em;}</style>
<style type="text/css">@page {size: 6in 9in; }@page :blank {}.shorttitle1 {string-set: h1-text content(text);}.shorttitle2 {string-set: h2-text content(text);}.running-h1-title {position: running(runningH1Title);width: var(--running-title-width);text-overflow: ellipsis;overflow: hidden;}.running-h1-title:before {content: string(h1-text);}@page chapter:left {@top-left {content: counter(page);}@top-right {content: element(runningH1Title);white-space: nowrap !important;}}.running-h2-title {position: running(runningH2Title);width: var(--running-title-width);text-overflow: ellipsis;overflow: hidden;}.running-h2-title:before {content: string(h2-text);}@page chapter:right {@top-right {content: counter(page);}@top-left {content: element(runningH2Title);white-space: nowrap !important;}}@page chapter:first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: counter(page);}}@page :first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: none !important;}background-image: var(--front-cover);background-position: center;background-size: contain;background-repeat: no-repeat;}.front-cover {break-after: recto;}.front-page {counter-reset: page 1;}@page frontmatter:left {@top-left {content: counter(page, lower-roman);}@top-right {content: element(runningH1Title);white-space: nowrap !important;}}@page frontmatter:left {@top-right {content: counter(page, lower-roman);}@top-left {content: element(runningH1Title);white-space: nowrap !important;}}@page frontmatter:first {@top-left {content: none;}@top-right {content: none;}@bottom-right {content: counter(page, lower-roman);}}.back-cover {break-before: verso;}.pagedjs_page:nth-last-of-type(1) {background-image: var(--back-cover);background-position: center;background-size: contain;background-repeat: no-repeat;}.level1 {break-before: avoid;page: chapter;}.front-matter-container .level1 {page: frontmatter;}.section > h1, .section > h2, .section > h3, .section > h4, .section > h5, .section > h6 {break-before: avoid;break-after: avoid;}.footenotes {break-before: always;break-after: always;}.figure {break-inside: avoid;}.main .level1:first-child h1 {counter-reset: page 1;}caption {break-inside: avoid;break-after: avoid;}</style>
<style type="text/css">:root {--background: whitesmoke;--pagedjs-width: 6in;--pagedjs-height: 9in;--color-paper: white;--color-mbox: rgba(0, 0, 0, 0.2);--running-title-width: 2.5in;--screen-pages-spacing: 5mm;}html {line-height: 1.3;}.abstract {border-width: 0.5px 0;border-style: solid;margin-top: 0px;margin-bottom: 2px;font-size: 12px;}a[href^="http"]:not([class="uri"])::after {content: " (" attr(href) ")";font-size: 90%;hyphens: none;word-break: break-all;}.references a[href^=http]:not([class=uri])::after {content: none;}.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: " (page " target-counter(attr(href), page) ")";}.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: " (page " target-counter(attr(href), page, lower-roman) ")";}.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {content: unset;}h1 {font-weight: bold;font-size: 23px;}h2 {font-weight: bold;font-size: 20px;}p {font-size: 12px;}.sourceCode {font-size: 10px;}.toc ul, .lot ul, .lof ul {list-style: none;padding-left: 0;overflow-x: hidden;}.toc li li {padding-left: 1em;}.toc a, .lot a, .lof a {text-decoration: none;background: white;padding-right: .33em;font-size: 11px;}.toc a::after, .lot a::after, .lof a::after {content: target-counter(attr(href), page);float: right;background: white;}.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {content: target-counter(attr(href), page, lower-roman);}.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {float: left;width: 0;white-space: nowrap;content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";}.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {content: var(--chapter-name-before, "Chapter ");}.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {content: var(--chapter-name-after, "");}.subtitle span {font-size: .9em;}img {max-width: 100%;}pre {padding: 1em;white-space: pre-wrap;}pre[class] {background: #f9f9f9;}abbr {text-decoration: none;}@media screen {div.sourceCode {overflow: visible !important;}a.sourceLine::before {text-decoration: unset !important;}}pre.numberSource a.sourceLine {left: 0 !important;text-indent: -5em}pre.numberSource {margin-left: 0 !important;}table {margin: auto;border-top: 1px solid #666;border-bottom: 1px solid #666;}table thead th {border-bottom: 1px solid #ddd;}thead, tfoot, tr:nth-child(even) {background: #eee;}.kable_wrapper > tbody > tr > td {vertical-align: top;}.footnotes {font-size: 90%;}.footnotes hr::before {content: "Footnotes:";}.footnotes hr {border: none;}.footnote-break {width: 1in;}body {hyphens: auto;}code {hyphens: none;}@media screen {body {background-color: var(--background);margin: var(--screen-pages-spacing) auto 0 auto;}.pagedjs_pages {display: flex;max-width: calc(var(--pagedjs-width) * 2);flex: 0;flex-wrap: wrap;margin: 0 auto;}.pagedjs_page {background-color: var(--color-paper);box-shadow: 0 0 0 1px var(--color-mbox);flex-shrink: 0;flex-grow: 0;margin: auto auto var(--screen-pages-spacing) auto;}}@media screen and (min-width: 12.32in) {.pagedjs_page {margin: auto 0 var(--screen-pages-spacing) 0;}.pagedjs_first_page {margin-left: var(--pagedjs-width);}}@media screen and (max-width:1180px) {body {width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));}}</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Question 2</h1>
<h5 class="author">Andrea Gauna</h5>
<h5 class="date">2022-06-17</h5>
</div>
</div>

<div class="front-matter-container">
<div id="TOC" class="level1 toc front-matter">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#do-you-really-like-wet-socks">Do you really like wet socks?</a>
<ul>
<li><a href="#table-1-the-frequency-of-rainy-days-in-london">Table 1: The frequency of rainy days in London</a></li>
</ul></li>
<li><a href="#wet-and-cold-no-thank-you">Wet and cold? No thank you</a>
<ul>
<li><a href="#figure-1-the-average-tempreture-in-london-in-2020">Figure 1: The average tempreture in London in 2020</a></li>
</ul></li>
<li><a href="#theres-a-lot-of-snow-in-london">There’s a lot of snow in London</a></li>
</ul>
</div>
</div>

<div class="main">
<div class="page-break-after"></div>
<div id="introduction" class="section level1 unnumbered">
<h1>Introduction</h1>
<p>There are so many reasons not to move to London but in this document I will name but a few. London is cold, London in rainy and third, there is a zero percent change of running into me.</p>
</div>
<div id="do-you-really-like-wet-socks" class="section level1 unnumbered">
<h1>Do you really like wet socks?</h1>
<p>It rains nearly 50% of the time! The amount of rain in London basically guarantees you’ll be stomping in puddles and going to work with wet socks. Do you really like wet socks? (Note: I kept receiving the error: Error in dir.exists(lib.loc) : invalid filename argument and i couldn’t fix it in time so I just screengrabbed the tables so I could knit my markdown, the code for the table is in “frequencytable.R”).</p>
<div id="table-1-the-frequency-of-rainy-days-in-london" class="section level2 unnumbered">
<h2>Table 1: The frequency of rainy days in London</h2>
<p><img src="data:image/png;base64,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" /></p>
</div>
</div>
<div id="wet-and-cold-no-thank-you" class="section level1 unnumbered">
<h1>Wet and cold? No thank you</h1>
<p>Not only is London super wet. It is also super cold. Where the average annual temperature in London is a chilly 12.7 degrees, in sunny South Africa it is 17.5 degrees. From the graph below it is clear than many days are spent below the average in London.</p>
<div id="figure-1-the-average-tempreture-in-london-in-2020" class="section level2 unnumbered">
<h2>Figure 1: The average tempreture in London in 2020</h2>
<p><img src="data:image/png;base64,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" width="672" /></p>
</div>
</div>
<div id="theres-a-lot-of-snow-in-london" class="section level1 unnumbered">
<h1>There’s a lot of snow in London</h1>
<p>The maximum snow depth in London is taller than a small cat, this is an illustration of what that might look like.</p>
<p><img src="data:image/png;base64,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" width="672" /></p>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
